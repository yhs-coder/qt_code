// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#include "data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Protocol {
PROTOBUF_CONSTEXPR Ethernet::Ethernet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.dst_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.src_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EthernetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EthernetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EthernetDefaultTypeInternal() {}
  union {
    Ethernet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EthernetDefaultTypeInternal _Ethernet_default_instance_;
PROTOBUF_CONSTEXPR Arp::Arp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.source_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.hardware_type_)*/0u
  , /*decltype(_impl_.protocol_type_)*/0u
  , /*decltype(_impl_.hardware_size_)*/0u
  , /*decltype(_impl_.protocol_size_)*/0u
  , /*decltype(_impl_.op_type_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ArpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArpDefaultTypeInternal() {}
  union {
    Arp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArpDefaultTypeInternal _Arp_default_instance_;
PROTOBUF_CONSTEXPR Ip::Ip(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.target_ip_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.header_len_)*/0u
  , /*decltype(_impl_.service_type_)*/0u
  , /*decltype(_impl_.total_len_)*/0u
  , /*decltype(_impl_.identification_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.fragment_offset_)*/0u
  , /*decltype(_impl_.ttl_)*/0u
  , /*decltype(_impl_.protocol_)*/0u
  , /*decltype(_impl_.checksum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct IpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IpDefaultTypeInternal() {}
  union {
    Ip _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IpDefaultTypeInternal _Ip_default_instance_;
PROTOBUF_CONSTEXPR Udp::Udp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_port_)*/0u
  , /*decltype(_impl_.target_port_)*/0u
  , /*decltype(_impl_.total_size_)*/0u
  , /*decltype(_impl_.check_sum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UdpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UdpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UdpDefaultTypeInternal() {}
  union {
    Udp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UdpDefaultTypeInternal _Udp_default_instance_;
PROTOBUF_CONSTEXPR Dns::Dns(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transaction_id_)*/0u
  , /*decltype(_impl_.op_code_)*/0u
  , /*decltype(_impl_.is_response_)*/false
  , /*decltype(_impl_.is_authenticated_answer_)*/false
  , /*decltype(_impl_.is_truncated_)*/false
  , /*decltype(_impl_.is_recursion_desired_)*/false
  , /*decltype(_impl_.is_recursion_available_)*/false
  , /*decltype(_impl_.reply_code_)*/0u
  , /*decltype(_impl_.question_amount_)*/0u
  , /*decltype(_impl_.answer_amount_)*/0u
  , /*decltype(_impl_.authority_amount_)*/0u
  , /*decltype(_impl_.additional_amount_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DnsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DnsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DnsDefaultTypeInternal() {}
  union {
    Dns _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DnsDefaultTypeInternal _Dns_default_instance_;
PROTOBUF_CONSTEXPR Tcp::Tcp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_port_)*/0u
  , /*decltype(_impl_.target_port_)*/0u
  , /*decltype(_impl_.seq_num_)*/0u
  , /*decltype(_impl_.ack_num_)*/0u
  , /*decltype(_impl_.header_len_)*/0u
  , /*decltype(_impl_.reserve_)*/0u
  , /*decltype(_impl_.urg_)*/false
  , /*decltype(_impl_.syn_)*/false
  , /*decltype(_impl_.ack_)*/false
  , /*decltype(_impl_.window_)*/0u
  , /*decltype(_impl_.checksum_)*/0u
  , /*decltype(_impl_.urgent_pointer_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TcpDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TcpDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TcpDefaultTypeInternal() {}
  union {
    Tcp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TcpDefaultTypeInternal _Tcp_default_instance_;
PROTOBUF_CONSTEXPR HttpRet_HeadersEntry_DoNotUse::HttpRet_HeadersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HttpRet_HeadersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal _HttpRet_HeadersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR HttpRet::HttpRet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.headers_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.method_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.http_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HttpRetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HttpRetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HttpRetDefaultTypeInternal() {}
  union {
    HttpRet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpRetDefaultTypeInternal _HttpRet_default_instance_;
PROTOBUF_CONSTEXPR HttpRes_HeadersEntry_DoNotUse::HttpRes_HeadersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    HttpRes_HeadersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal _HttpRes_HeadersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR HttpRes::HttpRes(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.headers_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.http_version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.status_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.phrase_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HttpResDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HttpResDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HttpResDefaultTypeInternal() {}
  union {
    HttpRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpResDefaultTypeInternal _HttpRes_default_instance_;
PROTOBUF_CONSTEXPR ProtocolData::ProtocolData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.time_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.eth_)*/nullptr
  , /*decltype(_impl_.arp_)*/nullptr
  , /*decltype(_impl_.ip_)*/nullptr
  , /*decltype(_impl_.udp_)*/nullptr
  , /*decltype(_impl_.dns_)*/nullptr
  , /*decltype(_impl_.tcp_)*/nullptr
  , /*decltype(_impl_.http_request_)*/nullptr
  , /*decltype(_impl_.http_response_)*/nullptr
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.caplen_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProtocolDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtocolDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtocolDataDefaultTypeInternal() {}
  union {
    ProtocolData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtocolDataDefaultTypeInternal _ProtocolData_default_instance_;
}  // namespace Protocol
static ::_pb::Metadata file_level_metadata_data_2eproto[11];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_data_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_data_2eproto = nullptr;

const uint32_t TableStruct_data_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Ethernet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Ethernet, _impl_.dst_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ethernet, _impl_.src_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.hardware_type_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.protocol_type_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.hardware_size_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.protocol_size_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.op_type_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.source_mac_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.source_ip_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.target_mac_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Arp, _impl_.target_ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.header_len_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.service_type_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.total_len_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.identification_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.fragment_offset_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.ttl_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.checksum_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.source_ip_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Ip, _impl_.target_ip_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Udp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Udp, _impl_.source_port_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Udp, _impl_.target_port_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Udp, _impl_.total_size_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Udp, _impl_.check_sum_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.transaction_id_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.is_response_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.op_code_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.is_authenticated_answer_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.is_truncated_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.is_recursion_desired_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.is_recursion_available_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.reply_code_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.question_amount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.answer_amount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.authority_amount_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Dns, _impl_.additional_amount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.source_port_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.target_port_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.seq_num_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.ack_num_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.header_len_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.reserve_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.urg_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.syn_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.ack_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.window_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.checksum_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.urgent_pointer_),
  PROTOBUF_FIELD_OFFSET(::Protocol::Tcp, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet_HeadersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet_HeadersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet_HeadersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet_HeadersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _impl_.headers_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _impl_.method_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _impl_.http_version_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRet, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes_HeadersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes_HeadersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes_HeadersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes_HeadersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _impl_.headers_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _impl_.http_version_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _impl_.status_code_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _impl_.phrase_),
  PROTOBUF_FIELD_OFFSET(::Protocol::HttpRes, _impl_.body_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.eth_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.arp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.udp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.dns_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.tcp_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.http_request_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.http_response_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::Protocol::ProtocolData, _impl_.caplen_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::Protocol::Ethernet)},
  { 8, -1, -1, sizeof(::Protocol::Arp)},
  { 23, -1, -1, sizeof(::Protocol::Ip)},
  { 41, -1, -1, sizeof(::Protocol::Udp)},
  { 51, -1, -1, sizeof(::Protocol::Dns)},
  { 69, -1, -1, sizeof(::Protocol::Tcp)},
  { 88, 96, -1, sizeof(::Protocol::HttpRet_HeadersEntry_DoNotUse)},
  { 98, -1, -1, sizeof(::Protocol::HttpRet)},
  { 109, 117, -1, sizeof(::Protocol::HttpRes_HeadersEntry_DoNotUse)},
  { 119, -1, -1, sizeof(::Protocol::HttpRes)},
  { 130, -1, -1, sizeof(::Protocol::ProtocolData)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::Protocol::_Ethernet_default_instance_._instance,
  &::Protocol::_Arp_default_instance_._instance,
  &::Protocol::_Ip_default_instance_._instance,
  &::Protocol::_Udp_default_instance_._instance,
  &::Protocol::_Dns_default_instance_._instance,
  &::Protocol::_Tcp_default_instance_._instance,
  &::Protocol::_HttpRet_HeadersEntry_DoNotUse_default_instance_._instance,
  &::Protocol::_HttpRet_default_instance_._instance,
  &::Protocol::_HttpRes_HeadersEntry_DoNotUse_default_instance_._instance,
  &::Protocol::_HttpRes_default_instance_._instance,
  &::Protocol::_ProtocolData_default_instance_._instance,
};

const char descriptor_table_protodef_data_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\ndata.proto\022\010Protocol\"$\n\010Ethernet\022\013\n\003ds"
  "t\030\001 \001(\t\022\013\n\003src\030\002 \001(\t\"\300\001\n\003Arp\022\025\n\rhardware"
  "_type\030\001 \001(\r\022\025\n\rprotocol_type\030\002 \001(\r\022\025\n\rha"
  "rdware_size\030\003 \001(\r\022\025\n\rprotocol_size\030\004 \001(\r"
  "\022\017\n\007op_type\030\005 \001(\r\022\022\n\nsource_mac\030\006 \001(\t\022\021\n"
  "\tsource_ip\030\007 \001(\t\022\022\n\ntarget_mac\030\010 \001(\t\022\021\n\t"
  "target_ip\030\t \001(\t\"\351\001\n\002Ip\022\017\n\007version\030\001 \001(\r\022"
  "\022\n\nheader_len\030\002 \001(\r\022\024\n\014service_type\030\003 \001("
  "\r\022\021\n\ttotal_len\030\004 \001(\r\022\026\n\016identification\030\005"
  " \001(\r\022\r\n\005flags\030\006 \001(\r\022\027\n\017fragment_offset\030\007"
  " \001(\r\022\013\n\003ttl\030\010 \001(\r\022\020\n\010protocol\030\t \001(\r\022\020\n\010c"
  "hecksum\030\n \001(\r\022\021\n\tsource_ip\030\013 \001(\t\022\021\n\ttarg"
  "et_ip\030\014 \001(\t\"V\n\003Udp\022\023\n\013source_port\030\001 \001(\r\022"
  "\023\n\013target_port\030\002 \001(\r\022\022\n\ntotal_size\030\003 \001(\r"
  "\022\021\n\tcheck_sum\030\004 \001(\r\"\261\002\n\003Dns\022\026\n\016transacti"
  "on_id\030\001 \001(\r\022\023\n\013is_response\030\002 \001(\010\022\017\n\007op_c"
  "ode\030\003 \001(\r\022\037\n\027is_authenticated_answer\030\004 \001"
  "(\010\022\024\n\014is_truncated\030\005 \001(\010\022\034\n\024is_recursion"
  "_desired\030\006 \001(\010\022\036\n\026is_recursion_available"
  "\030\007 \001(\010\022\022\n\nreply_code\030\010 \001(\r\022\027\n\017question_a"
  "mount\030\t \001(\r\022\025\n\ranswer_amount\030\n \001(\r\022\030\n\020au"
  "thority_amount\030\013 \001(\r\022\031\n\021additional_amoun"
  "t\030\014 \001(\r\"\346\001\n\003Tcp\022\023\n\013source_port\030\001 \001(\r\022\023\n\013"
  "target_port\030\002 \001(\r\022\017\n\007seq_num\030\003 \001(\r\022\017\n\007ac"
  "k_num\030\004 \001(\r\022\022\n\nheader_len\030\005 \001(\r\022\017\n\007reser"
  "ve\030\006 \001(\r\022\013\n\003urg\030\007 \001(\010\022\013\n\003syn\030\010 \001(\010\022\013\n\003ac"
  "k\030\t \001(\010\022\016\n\006window\030\n \001(\r\022\020\n\010checksum\030\013 \001("
  "\r\022\026\n\016urgent_pointer\030\014 \001(\r\022\r\n\005flags\030\r \001(\r"
  "\"\254\001\n\007HttpRet\022/\n\007headers\030\001 \003(\0132\036.Protocol"
  ".HttpRet.HeadersEntry\022\016\n\006method\030\002 \001(\t\022\014\n"
  "\004path\030\003 \001(\t\022\024\n\014http_version\030\004 \001(\t\022\014\n\004bod"
  "y\030\005 \001(\t\032.\n\014HeadersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005"
  "value\030\002 \001(\t:\0028\001\"\263\001\n\007HttpRes\022/\n\007headers\030\001"
  " \003(\0132\036.Protocol.HttpRes.HeadersEntry\022\024\n\014"
  "http_version\030\002 \001(\t\022\023\n\013status_code\030\003 \001(\t\022"
  "\016\n\006phrase\030\004 \001(\t\022\014\n\004body\030\005 \001(\t\032.\n\014Headers"
  "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"\270\002"
  "\n\014ProtocolData\022\037\n\003eth\030\001 \001(\0132\022.Protocol.E"
  "thernet\022\032\n\003arp\030\002 \001(\0132\r.Protocol.Arp\022\030\n\002i"
  "p\030\003 \001(\0132\014.Protocol.Ip\022\032\n\003udp\030\004 \001(\0132\r.Pro"
  "tocol.Udp\022\032\n\003dns\030\005 \001(\0132\r.Protocol.Dns\022\032\n"
  "\003tcp\030\006 \001(\0132\r.Protocol.Tcp\022\'\n\014http_reques"
  "t\030\007 \001(\0132\021.Protocol.HttpRet\022(\n\rhttp_respo"
  "nse\030\010 \001(\0132\021.Protocol.HttpRes\022\014\n\004type\030\t \001"
  "(\r\022\014\n\004time\030\n \001(\t\022\016\n\006caplen\030\013 \001(\rb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_data_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_data_2eproto = {
    false, false, 1800, descriptor_table_protodef_data_2eproto,
    "data.proto",
    &descriptor_table_data_2eproto_once, nullptr, 0, 11,
    schemas, file_default_instances, TableStruct_data_2eproto::offsets,
    file_level_metadata_data_2eproto, file_level_enum_descriptors_data_2eproto,
    file_level_service_descriptors_data_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_data_2eproto_getter() {
  return &descriptor_table_data_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_data_2eproto(&descriptor_table_data_2eproto);
namespace Protocol {

// ===================================================================

class Ethernet::_Internal {
 public:
};

Ethernet::Ethernet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Ethernet)
}
Ethernet::Ethernet(const Ethernet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ethernet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.dst_){}
    , decltype(_impl_.src_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.dst_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dst().empty()) {
    _this->_impl_.dst_.Set(from._internal_dst(), 
      _this->GetArenaForAllocation());
  }
  _impl_.src_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_src().empty()) {
    _this->_impl_.src_.Set(from._internal_src(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.Ethernet)
}

inline void Ethernet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.dst_){}
    , decltype(_impl_.src_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.dst_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dst_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.src_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.src_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Ethernet::~Ethernet() {
  // @@protoc_insertion_point(destructor:Protocol.Ethernet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ethernet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dst_.Destroy();
  _impl_.src_.Destroy();
}

void Ethernet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ethernet::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Ethernet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dst_.ClearToEmpty();
  _impl_.src_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ethernet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string dst = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_dst();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Ethernet.dst"));
        } else
          goto handle_unusual;
        continue;
      // string src = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_src();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Ethernet.src"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ethernet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Ethernet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string dst = 1;
  if (!this->_internal_dst().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dst().data(), static_cast<int>(this->_internal_dst().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Ethernet.dst");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_dst(), target);
  }

  // string src = 2;
  if (!this->_internal_src().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_src().data(), static_cast<int>(this->_internal_src().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Ethernet.src");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_src(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Ethernet)
  return target;
}

size_t Ethernet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Ethernet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string dst = 1;
  if (!this->_internal_dst().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dst());
  }

  // string src = 2;
  if (!this->_internal_src().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ethernet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ethernet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ethernet::GetClassData() const { return &_class_data_; }


void Ethernet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ethernet*>(&to_msg);
  auto& from = static_cast<const Ethernet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Ethernet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_dst().empty()) {
    _this->_internal_set_dst(from._internal_dst());
  }
  if (!from._internal_src().empty()) {
    _this->_internal_set_src(from._internal_src());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ethernet::CopyFrom(const Ethernet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Ethernet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ethernet::IsInitialized() const {
  return true;
}

void Ethernet::InternalSwap(Ethernet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dst_, lhs_arena,
      &other->_impl_.dst_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.src_, lhs_arena,
      &other->_impl_.src_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Ethernet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[0]);
}

// ===================================================================

class Arp::_Internal {
 public:
};

Arp::Arp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Arp)
}
Arp::Arp(const Arp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Arp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_mac_){}
    , decltype(_impl_.source_ip_){}
    , decltype(_impl_.target_mac_){}
    , decltype(_impl_.target_ip_){}
    , decltype(_impl_.hardware_type_){}
    , decltype(_impl_.protocol_type_){}
    , decltype(_impl_.hardware_size_){}
    , decltype(_impl_.protocol_size_){}
    , decltype(_impl_.op_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.source_mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_mac().empty()) {
    _this->_impl_.source_mac_.Set(from._internal_source_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.source_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_ip().empty()) {
    _this->_impl_.source_ip_.Set(from._internal_source_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target_mac().empty()) {
    _this->_impl_.target_mac_.Set(from._internal_target_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target_ip().empty()) {
    _this->_impl_.target_ip_.Set(from._internal_target_ip(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.hardware_type_, &from._impl_.hardware_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.op_type_) -
    reinterpret_cast<char*>(&_impl_.hardware_type_)) + sizeof(_impl_.op_type_));
  // @@protoc_insertion_point(copy_constructor:Protocol.Arp)
}

inline void Arp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_mac_){}
    , decltype(_impl_.source_ip_){}
    , decltype(_impl_.target_mac_){}
    , decltype(_impl_.target_ip_){}
    , decltype(_impl_.hardware_type_){0u}
    , decltype(_impl_.protocol_type_){0u}
    , decltype(_impl_.hardware_size_){0u}
    , decltype(_impl_.protocol_size_){0u}
    , decltype(_impl_.op_type_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.source_mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.source_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Arp::~Arp() {
  // @@protoc_insertion_point(destructor:Protocol.Arp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Arp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_mac_.Destroy();
  _impl_.source_ip_.Destroy();
  _impl_.target_mac_.Destroy();
  _impl_.target_ip_.Destroy();
}

void Arp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Arp::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Arp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_mac_.ClearToEmpty();
  _impl_.source_ip_.ClearToEmpty();
  _impl_.target_mac_.ClearToEmpty();
  _impl_.target_ip_.ClearToEmpty();
  ::memset(&_impl_.hardware_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.op_type_) -
      reinterpret_cast<char*>(&_impl_.hardware_type_)) + sizeof(_impl_.op_type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Arp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 hardware_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.hardware_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 protocol_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.protocol_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 hardware_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.hardware_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 protocol_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.protocol_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 op_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.op_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string source_mac = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_source_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Arp.source_mac"));
        } else
          goto handle_unusual;
        continue;
      // string source_ip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_source_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Arp.source_ip"));
        } else
          goto handle_unusual;
        continue;
      // string target_mac = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_target_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Arp.target_mac"));
        } else
          goto handle_unusual;
        continue;
      // string target_ip = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_target_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Arp.target_ip"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Arp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Arp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 hardware_type = 1;
  if (this->_internal_hardware_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hardware_type(), target);
  }

  // uint32 protocol_type = 2;
  if (this->_internal_protocol_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_protocol_type(), target);
  }

  // uint32 hardware_size = 3;
  if (this->_internal_hardware_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hardware_size(), target);
  }

  // uint32 protocol_size = 4;
  if (this->_internal_protocol_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_protocol_size(), target);
  }

  // uint32 op_type = 5;
  if (this->_internal_op_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_op_type(), target);
  }

  // string source_mac = 6;
  if (!this->_internal_source_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_mac().data(), static_cast<int>(this->_internal_source_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Arp.source_mac");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_source_mac(), target);
  }

  // string source_ip = 7;
  if (!this->_internal_source_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_ip().data(), static_cast<int>(this->_internal_source_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Arp.source_ip");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_source_ip(), target);
  }

  // string target_mac = 8;
  if (!this->_internal_target_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target_mac().data(), static_cast<int>(this->_internal_target_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Arp.target_mac");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_target_mac(), target);
  }

  // string target_ip = 9;
  if (!this->_internal_target_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target_ip().data(), static_cast<int>(this->_internal_target_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Arp.target_ip");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_target_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Arp)
  return target;
}

size_t Arp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Arp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string source_mac = 6;
  if (!this->_internal_source_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_mac());
  }

  // string source_ip = 7;
  if (!this->_internal_source_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_ip());
  }

  // string target_mac = 8;
  if (!this->_internal_target_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target_mac());
  }

  // string target_ip = 9;
  if (!this->_internal_target_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target_ip());
  }

  // uint32 hardware_type = 1;
  if (this->_internal_hardware_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hardware_type());
  }

  // uint32 protocol_type = 2;
  if (this->_internal_protocol_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_type());
  }

  // uint32 hardware_size = 3;
  if (this->_internal_hardware_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hardware_size());
  }

  // uint32 protocol_size = 4;
  if (this->_internal_protocol_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol_size());
  }

  // uint32 op_type = 5;
  if (this->_internal_op_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Arp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Arp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Arp::GetClassData() const { return &_class_data_; }


void Arp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Arp*>(&to_msg);
  auto& from = static_cast<const Arp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Arp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_source_mac().empty()) {
    _this->_internal_set_source_mac(from._internal_source_mac());
  }
  if (!from._internal_source_ip().empty()) {
    _this->_internal_set_source_ip(from._internal_source_ip());
  }
  if (!from._internal_target_mac().empty()) {
    _this->_internal_set_target_mac(from._internal_target_mac());
  }
  if (!from._internal_target_ip().empty()) {
    _this->_internal_set_target_ip(from._internal_target_ip());
  }
  if (from._internal_hardware_type() != 0) {
    _this->_internal_set_hardware_type(from._internal_hardware_type());
  }
  if (from._internal_protocol_type() != 0) {
    _this->_internal_set_protocol_type(from._internal_protocol_type());
  }
  if (from._internal_hardware_size() != 0) {
    _this->_internal_set_hardware_size(from._internal_hardware_size());
  }
  if (from._internal_protocol_size() != 0) {
    _this->_internal_set_protocol_size(from._internal_protocol_size());
  }
  if (from._internal_op_type() != 0) {
    _this->_internal_set_op_type(from._internal_op_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Arp::CopyFrom(const Arp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Arp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Arp::IsInitialized() const {
  return true;
}

void Arp::InternalSwap(Arp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_mac_, lhs_arena,
      &other->_impl_.source_mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_ip_, lhs_arena,
      &other->_impl_.source_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_mac_, lhs_arena,
      &other->_impl_.target_mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_ip_, lhs_arena,
      &other->_impl_.target_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Arp, _impl_.op_type_)
      + sizeof(Arp::_impl_.op_type_)
      - PROTOBUF_FIELD_OFFSET(Arp, _impl_.hardware_type_)>(
          reinterpret_cast<char*>(&_impl_.hardware_type_),
          reinterpret_cast<char*>(&other->_impl_.hardware_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Arp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[1]);
}

// ===================================================================

class Ip::_Internal {
 public:
};

Ip::Ip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Ip)
}
Ip::Ip(const Ip& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ip* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_ip_){}
    , decltype(_impl_.target_ip_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.header_len_){}
    , decltype(_impl_.service_type_){}
    , decltype(_impl_.total_len_){}
    , decltype(_impl_.identification_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.fragment_offset_){}
    , decltype(_impl_.ttl_){}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.checksum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.source_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_source_ip().empty()) {
    _this->_impl_.source_ip_.Set(from._internal_source_ip(), 
      _this->GetArenaForAllocation());
  }
  _impl_.target_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_target_ip().empty()) {
    _this->_impl_.target_ip_.Set(from._internal_target_ip(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.version_, &from._impl_.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.checksum_) -
    reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.checksum_));
  // @@protoc_insertion_point(copy_constructor:Protocol.Ip)
}

inline void Ip::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_ip_){}
    , decltype(_impl_.target_ip_){}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.header_len_){0u}
    , decltype(_impl_.service_type_){0u}
    , decltype(_impl_.total_len_){0u}
    , decltype(_impl_.identification_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.fragment_offset_){0u}
    , decltype(_impl_.ttl_){0u}
    , decltype(_impl_.protocol_){0u}
    , decltype(_impl_.checksum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.source_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.target_ip_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Ip::~Ip() {
  // @@protoc_insertion_point(destructor:Protocol.Ip)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ip::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.source_ip_.Destroy();
  _impl_.target_ip_.Destroy();
}

void Ip::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ip::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Ip)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.source_ip_.ClearToEmpty();
  _impl_.target_ip_.ClearToEmpty();
  ::memset(&_impl_.version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.checksum_) -
      reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.checksum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ip::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 header_len = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.header_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 service_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.service_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 total_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.total_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 identification = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.identification_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 fragment_offset = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.fragment_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ttl = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 protocol = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 checksum = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string source_ip = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_source_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Ip.source_ip"));
        } else
          goto handle_unusual;
        continue;
      // string target_ip = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_target_ip();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.Ip.target_ip"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ip::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Ip)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 version = 1;
  if (this->_internal_version() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // uint32 header_len = 2;
  if (this->_internal_header_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_header_len(), target);
  }

  // uint32 service_type = 3;
  if (this->_internal_service_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_service_type(), target);
  }

  // uint32 total_len = 4;
  if (this->_internal_total_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_total_len(), target);
  }

  // uint32 identification = 5;
  if (this->_internal_identification() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_identification(), target);
  }

  // uint32 flags = 6;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_flags(), target);
  }

  // uint32 fragment_offset = 7;
  if (this->_internal_fragment_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_fragment_offset(), target);
  }

  // uint32 ttl = 8;
  if (this->_internal_ttl() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_ttl(), target);
  }

  // uint32 protocol = 9;
  if (this->_internal_protocol() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_protocol(), target);
  }

  // uint32 checksum = 10;
  if (this->_internal_checksum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_checksum(), target);
  }

  // string source_ip = 11;
  if (!this->_internal_source_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_source_ip().data(), static_cast<int>(this->_internal_source_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Ip.source_ip");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_source_ip(), target);
  }

  // string target_ip = 12;
  if (!this->_internal_target_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_target_ip().data(), static_cast<int>(this->_internal_target_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.Ip.target_ip");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_target_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Ip)
  return target;
}

size_t Ip::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Ip)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string source_ip = 11;
  if (!this->_internal_source_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_source_ip());
  }

  // string target_ip = 12;
  if (!this->_internal_target_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_target_ip());
  }

  // uint32 version = 1;
  if (this->_internal_version() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
  }

  // uint32 header_len = 2;
  if (this->_internal_header_len() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_len());
  }

  // uint32 service_type = 3;
  if (this->_internal_service_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_service_type());
  }

  // uint32 total_len = 4;
  if (this->_internal_total_len() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_len());
  }

  // uint32 identification = 5;
  if (this->_internal_identification() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_identification());
  }

  // uint32 flags = 6;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  // uint32 fragment_offset = 7;
  if (this->_internal_fragment_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fragment_offset());
  }

  // uint32 ttl = 8;
  if (this->_internal_ttl() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ttl());
  }

  // uint32 protocol = 9;
  if (this->_internal_protocol() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_protocol());
  }

  // uint32 checksum = 10;
  if (this->_internal_checksum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_checksum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ip::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ip::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ip::GetClassData() const { return &_class_data_; }


void Ip::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ip*>(&to_msg);
  auto& from = static_cast<const Ip&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Ip)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_source_ip().empty()) {
    _this->_internal_set_source_ip(from._internal_source_ip());
  }
  if (!from._internal_target_ip().empty()) {
    _this->_internal_set_target_ip(from._internal_target_ip());
  }
  if (from._internal_version() != 0) {
    _this->_internal_set_version(from._internal_version());
  }
  if (from._internal_header_len() != 0) {
    _this->_internal_set_header_len(from._internal_header_len());
  }
  if (from._internal_service_type() != 0) {
    _this->_internal_set_service_type(from._internal_service_type());
  }
  if (from._internal_total_len() != 0) {
    _this->_internal_set_total_len(from._internal_total_len());
  }
  if (from._internal_identification() != 0) {
    _this->_internal_set_identification(from._internal_identification());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_fragment_offset() != 0) {
    _this->_internal_set_fragment_offset(from._internal_fragment_offset());
  }
  if (from._internal_ttl() != 0) {
    _this->_internal_set_ttl(from._internal_ttl());
  }
  if (from._internal_protocol() != 0) {
    _this->_internal_set_protocol(from._internal_protocol());
  }
  if (from._internal_checksum() != 0) {
    _this->_internal_set_checksum(from._internal_checksum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ip::CopyFrom(const Ip& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Ip)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ip::IsInitialized() const {
  return true;
}

void Ip::InternalSwap(Ip* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.source_ip_, lhs_arena,
      &other->_impl_.source_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_ip_, lhs_arena,
      &other->_impl_.target_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ip, _impl_.checksum_)
      + sizeof(Ip::_impl_.checksum_)
      - PROTOBUF_FIELD_OFFSET(Ip, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ip::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[2]);
}

// ===================================================================

class Udp::_Internal {
 public:
};

Udp::Udp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Udp)
}
Udp::Udp(const Udp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Udp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_port_){}
    , decltype(_impl_.target_port_){}
    , decltype(_impl_.total_size_){}
    , decltype(_impl_.check_sum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.source_port_, &from._impl_.source_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.check_sum_) -
    reinterpret_cast<char*>(&_impl_.source_port_)) + sizeof(_impl_.check_sum_));
  // @@protoc_insertion_point(copy_constructor:Protocol.Udp)
}

inline void Udp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_port_){0u}
    , decltype(_impl_.target_port_){0u}
    , decltype(_impl_.total_size_){0u}
    , decltype(_impl_.check_sum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Udp::~Udp() {
  // @@protoc_insertion_point(destructor:Protocol.Udp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Udp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Udp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Udp::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Udp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.source_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.check_sum_) -
      reinterpret_cast<char*>(&_impl_.source_port_)) + sizeof(_impl_.check_sum_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Udp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 source_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 target_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.target_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 total_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.total_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 check_sum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.check_sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Udp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Udp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 source_port = 1;
  if (this->_internal_source_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source_port(), target);
  }

  // uint32 target_port = 2;
  if (this->_internal_target_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_target_port(), target);
  }

  // uint32 total_size = 3;
  if (this->_internal_total_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_total_size(), target);
  }

  // uint32 check_sum = 4;
  if (this->_internal_check_sum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_check_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Udp)
  return target;
}

size_t Udp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Udp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 source_port = 1;
  if (this->_internal_source_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_port());
  }

  // uint32 target_port = 2;
  if (this->_internal_target_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_port());
  }

  // uint32 total_size = 3;
  if (this->_internal_total_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_total_size());
  }

  // uint32 check_sum = 4;
  if (this->_internal_check_sum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_check_sum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Udp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Udp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Udp::GetClassData() const { return &_class_data_; }


void Udp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Udp*>(&to_msg);
  auto& from = static_cast<const Udp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Udp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_port() != 0) {
    _this->_internal_set_source_port(from._internal_source_port());
  }
  if (from._internal_target_port() != 0) {
    _this->_internal_set_target_port(from._internal_target_port());
  }
  if (from._internal_total_size() != 0) {
    _this->_internal_set_total_size(from._internal_total_size());
  }
  if (from._internal_check_sum() != 0) {
    _this->_internal_set_check_sum(from._internal_check_sum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Udp::CopyFrom(const Udp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Udp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Udp::IsInitialized() const {
  return true;
}

void Udp::InternalSwap(Udp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Udp, _impl_.check_sum_)
      + sizeof(Udp::_impl_.check_sum_)
      - PROTOBUF_FIELD_OFFSET(Udp, _impl_.source_port_)>(
          reinterpret_cast<char*>(&_impl_.source_port_),
          reinterpret_cast<char*>(&other->_impl_.source_port_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Udp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[3]);
}

// ===================================================================

class Dns::_Internal {
 public:
};

Dns::Dns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Dns)
}
Dns::Dns(const Dns& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Dns* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transaction_id_){}
    , decltype(_impl_.op_code_){}
    , decltype(_impl_.is_response_){}
    , decltype(_impl_.is_authenticated_answer_){}
    , decltype(_impl_.is_truncated_){}
    , decltype(_impl_.is_recursion_desired_){}
    , decltype(_impl_.is_recursion_available_){}
    , decltype(_impl_.reply_code_){}
    , decltype(_impl_.question_amount_){}
    , decltype(_impl_.answer_amount_){}
    , decltype(_impl_.authority_amount_){}
    , decltype(_impl_.additional_amount_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.transaction_id_, &from._impl_.transaction_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.additional_amount_) -
    reinterpret_cast<char*>(&_impl_.transaction_id_)) + sizeof(_impl_.additional_amount_));
  // @@protoc_insertion_point(copy_constructor:Protocol.Dns)
}

inline void Dns::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transaction_id_){0u}
    , decltype(_impl_.op_code_){0u}
    , decltype(_impl_.is_response_){false}
    , decltype(_impl_.is_authenticated_answer_){false}
    , decltype(_impl_.is_truncated_){false}
    , decltype(_impl_.is_recursion_desired_){false}
    , decltype(_impl_.is_recursion_available_){false}
    , decltype(_impl_.reply_code_){0u}
    , decltype(_impl_.question_amount_){0u}
    , decltype(_impl_.answer_amount_){0u}
    , decltype(_impl_.authority_amount_){0u}
    , decltype(_impl_.additional_amount_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Dns::~Dns() {
  // @@protoc_insertion_point(destructor:Protocol.Dns)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Dns::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Dns::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Dns::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Dns)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.transaction_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.additional_amount_) -
      reinterpret_cast<char*>(&_impl_.transaction_id_)) + sizeof(_impl_.additional_amount_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Dns::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 transaction_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.transaction_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.is_response_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 op_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.op_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_authenticated_answer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.is_authenticated_answer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_truncated = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.is_truncated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_recursion_desired = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_recursion_desired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_recursion_available = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.is_recursion_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reply_code = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.reply_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 question_amount = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.question_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 answer_amount = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.answer_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 authority_amount = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.authority_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 additional_amount = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.additional_amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Dns::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Dns)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 transaction_id = 1;
  if (this->_internal_transaction_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_transaction_id(), target);
  }

  // bool is_response = 2;
  if (this->_internal_is_response() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_response(), target);
  }

  // uint32 op_code = 3;
  if (this->_internal_op_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_op_code(), target);
  }

  // bool is_authenticated_answer = 4;
  if (this->_internal_is_authenticated_answer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_authenticated_answer(), target);
  }

  // bool is_truncated = 5;
  if (this->_internal_is_truncated() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_truncated(), target);
  }

  // bool is_recursion_desired = 6;
  if (this->_internal_is_recursion_desired() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_recursion_desired(), target);
  }

  // bool is_recursion_available = 7;
  if (this->_internal_is_recursion_available() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_recursion_available(), target);
  }

  // uint32 reply_code = 8;
  if (this->_internal_reply_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_reply_code(), target);
  }

  // uint32 question_amount = 9;
  if (this->_internal_question_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_question_amount(), target);
  }

  // uint32 answer_amount = 10;
  if (this->_internal_answer_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_answer_amount(), target);
  }

  // uint32 authority_amount = 11;
  if (this->_internal_authority_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_authority_amount(), target);
  }

  // uint32 additional_amount = 12;
  if (this->_internal_additional_amount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_additional_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Dns)
  return target;
}

size_t Dns::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Dns)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 transaction_id = 1;
  if (this->_internal_transaction_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_transaction_id());
  }

  // uint32 op_code = 3;
  if (this->_internal_op_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_op_code());
  }

  // bool is_response = 2;
  if (this->_internal_is_response() != 0) {
    total_size += 1 + 1;
  }

  // bool is_authenticated_answer = 4;
  if (this->_internal_is_authenticated_answer() != 0) {
    total_size += 1 + 1;
  }

  // bool is_truncated = 5;
  if (this->_internal_is_truncated() != 0) {
    total_size += 1 + 1;
  }

  // bool is_recursion_desired = 6;
  if (this->_internal_is_recursion_desired() != 0) {
    total_size += 1 + 1;
  }

  // bool is_recursion_available = 7;
  if (this->_internal_is_recursion_available() != 0) {
    total_size += 1 + 1;
  }

  // uint32 reply_code = 8;
  if (this->_internal_reply_code() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reply_code());
  }

  // uint32 question_amount = 9;
  if (this->_internal_question_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_question_amount());
  }

  // uint32 answer_amount = 10;
  if (this->_internal_answer_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_answer_amount());
  }

  // uint32 authority_amount = 11;
  if (this->_internal_authority_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_authority_amount());
  }

  // uint32 additional_amount = 12;
  if (this->_internal_additional_amount() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_additional_amount());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Dns::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Dns::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Dns::GetClassData() const { return &_class_data_; }


void Dns::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Dns*>(&to_msg);
  auto& from = static_cast<const Dns&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Dns)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_transaction_id() != 0) {
    _this->_internal_set_transaction_id(from._internal_transaction_id());
  }
  if (from._internal_op_code() != 0) {
    _this->_internal_set_op_code(from._internal_op_code());
  }
  if (from._internal_is_response() != 0) {
    _this->_internal_set_is_response(from._internal_is_response());
  }
  if (from._internal_is_authenticated_answer() != 0) {
    _this->_internal_set_is_authenticated_answer(from._internal_is_authenticated_answer());
  }
  if (from._internal_is_truncated() != 0) {
    _this->_internal_set_is_truncated(from._internal_is_truncated());
  }
  if (from._internal_is_recursion_desired() != 0) {
    _this->_internal_set_is_recursion_desired(from._internal_is_recursion_desired());
  }
  if (from._internal_is_recursion_available() != 0) {
    _this->_internal_set_is_recursion_available(from._internal_is_recursion_available());
  }
  if (from._internal_reply_code() != 0) {
    _this->_internal_set_reply_code(from._internal_reply_code());
  }
  if (from._internal_question_amount() != 0) {
    _this->_internal_set_question_amount(from._internal_question_amount());
  }
  if (from._internal_answer_amount() != 0) {
    _this->_internal_set_answer_amount(from._internal_answer_amount());
  }
  if (from._internal_authority_amount() != 0) {
    _this->_internal_set_authority_amount(from._internal_authority_amount());
  }
  if (from._internal_additional_amount() != 0) {
    _this->_internal_set_additional_amount(from._internal_additional_amount());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Dns::CopyFrom(const Dns& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Dns)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Dns::IsInitialized() const {
  return true;
}

void Dns::InternalSwap(Dns* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Dns, _impl_.additional_amount_)
      + sizeof(Dns::_impl_.additional_amount_)
      - PROTOBUF_FIELD_OFFSET(Dns, _impl_.transaction_id_)>(
          reinterpret_cast<char*>(&_impl_.transaction_id_),
          reinterpret_cast<char*>(&other->_impl_.transaction_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Dns::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[4]);
}

// ===================================================================

class Tcp::_Internal {
 public:
};

Tcp::Tcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.Tcp)
}
Tcp::Tcp(const Tcp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Tcp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_port_){}
    , decltype(_impl_.target_port_){}
    , decltype(_impl_.seq_num_){}
    , decltype(_impl_.ack_num_){}
    , decltype(_impl_.header_len_){}
    , decltype(_impl_.reserve_){}
    , decltype(_impl_.urg_){}
    , decltype(_impl_.syn_){}
    , decltype(_impl_.ack_){}
    , decltype(_impl_.window_){}
    , decltype(_impl_.checksum_){}
    , decltype(_impl_.urgent_pointer_){}
    , decltype(_impl_.flags_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.source_port_, &from._impl_.source_port_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.source_port_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:Protocol.Tcp)
}

inline void Tcp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_port_){0u}
    , decltype(_impl_.target_port_){0u}
    , decltype(_impl_.seq_num_){0u}
    , decltype(_impl_.ack_num_){0u}
    , decltype(_impl_.header_len_){0u}
    , decltype(_impl_.reserve_){0u}
    , decltype(_impl_.urg_){false}
    , decltype(_impl_.syn_){false}
    , decltype(_impl_.ack_){false}
    , decltype(_impl_.window_){0u}
    , decltype(_impl_.checksum_){0u}
    , decltype(_impl_.urgent_pointer_){0u}
    , decltype(_impl_.flags_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Tcp::~Tcp() {
  // @@protoc_insertion_point(destructor:Protocol.Tcp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Tcp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Tcp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Tcp::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.Tcp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.source_port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.flags_) -
      reinterpret_cast<char*>(&_impl_.source_port_)) + sizeof(_impl_.flags_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Tcp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 source_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.source_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 target_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.target_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 seq_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ack_num = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.ack_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 header_len = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.header_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reserve = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.reserve_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool urg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.urg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool syn = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.syn_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool ack = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.ack_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 window = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.window_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 checksum = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.checksum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 urgent_pointer = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.urgent_pointer_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 flags = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Tcp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.Tcp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 source_port = 1;
  if (this->_internal_source_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_source_port(), target);
  }

  // uint32 target_port = 2;
  if (this->_internal_target_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_target_port(), target);
  }

  // uint32 seq_num = 3;
  if (this->_internal_seq_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq_num(), target);
  }

  // uint32 ack_num = 4;
  if (this->_internal_ack_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ack_num(), target);
  }

  // uint32 header_len = 5;
  if (this->_internal_header_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_header_len(), target);
  }

  // uint32 reserve = 6;
  if (this->_internal_reserve() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_reserve(), target);
  }

  // bool urg = 7;
  if (this->_internal_urg() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_urg(), target);
  }

  // bool syn = 8;
  if (this->_internal_syn() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_syn(), target);
  }

  // bool ack = 9;
  if (this->_internal_ack() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_ack(), target);
  }

  // uint32 window = 10;
  if (this->_internal_window() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_window(), target);
  }

  // uint32 checksum = 11;
  if (this->_internal_checksum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_checksum(), target);
  }

  // uint32 urgent_pointer = 12;
  if (this->_internal_urgent_pointer() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_urgent_pointer(), target);
  }

  // uint32 flags = 13;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.Tcp)
  return target;
}

size_t Tcp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.Tcp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 source_port = 1;
  if (this->_internal_source_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_source_port());
  }

  // uint32 target_port = 2;
  if (this->_internal_target_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_target_port());
  }

  // uint32 seq_num = 3;
  if (this->_internal_seq_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num());
  }

  // uint32 ack_num = 4;
  if (this->_internal_ack_num() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ack_num());
  }

  // uint32 header_len = 5;
  if (this->_internal_header_len() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_header_len());
  }

  // uint32 reserve = 6;
  if (this->_internal_reserve() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reserve());
  }

  // bool urg = 7;
  if (this->_internal_urg() != 0) {
    total_size += 1 + 1;
  }

  // bool syn = 8;
  if (this->_internal_syn() != 0) {
    total_size += 1 + 1;
  }

  // bool ack = 9;
  if (this->_internal_ack() != 0) {
    total_size += 1 + 1;
  }

  // uint32 window = 10;
  if (this->_internal_window() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_window());
  }

  // uint32 checksum = 11;
  if (this->_internal_checksum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_checksum());
  }

  // uint32 urgent_pointer = 12;
  if (this->_internal_urgent_pointer() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_urgent_pointer());
  }

  // uint32 flags = 13;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Tcp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Tcp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Tcp::GetClassData() const { return &_class_data_; }


void Tcp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Tcp*>(&to_msg);
  auto& from = static_cast<const Tcp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.Tcp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_source_port() != 0) {
    _this->_internal_set_source_port(from._internal_source_port());
  }
  if (from._internal_target_port() != 0) {
    _this->_internal_set_target_port(from._internal_target_port());
  }
  if (from._internal_seq_num() != 0) {
    _this->_internal_set_seq_num(from._internal_seq_num());
  }
  if (from._internal_ack_num() != 0) {
    _this->_internal_set_ack_num(from._internal_ack_num());
  }
  if (from._internal_header_len() != 0) {
    _this->_internal_set_header_len(from._internal_header_len());
  }
  if (from._internal_reserve() != 0) {
    _this->_internal_set_reserve(from._internal_reserve());
  }
  if (from._internal_urg() != 0) {
    _this->_internal_set_urg(from._internal_urg());
  }
  if (from._internal_syn() != 0) {
    _this->_internal_set_syn(from._internal_syn());
  }
  if (from._internal_ack() != 0) {
    _this->_internal_set_ack(from._internal_ack());
  }
  if (from._internal_window() != 0) {
    _this->_internal_set_window(from._internal_window());
  }
  if (from._internal_checksum() != 0) {
    _this->_internal_set_checksum(from._internal_checksum());
  }
  if (from._internal_urgent_pointer() != 0) {
    _this->_internal_set_urgent_pointer(from._internal_urgent_pointer());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Tcp::CopyFrom(const Tcp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.Tcp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tcp::IsInitialized() const {
  return true;
}

void Tcp::InternalSwap(Tcp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Tcp, _impl_.flags_)
      + sizeof(Tcp::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(Tcp, _impl_.source_port_)>(
          reinterpret_cast<char*>(&_impl_.source_port_),
          reinterpret_cast<char*>(&other->_impl_.source_port_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Tcp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[5]);
}

// ===================================================================

HttpRet_HeadersEntry_DoNotUse::HttpRet_HeadersEntry_DoNotUse() {}
HttpRet_HeadersEntry_DoNotUse::HttpRet_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void HttpRet_HeadersEntry_DoNotUse::MergeFrom(const HttpRet_HeadersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata HttpRet_HeadersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[6]);
}

// ===================================================================

class HttpRet::_Internal {
 public:
};

HttpRet::HttpRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &HttpRet::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:Protocol.HttpRet)
}
HttpRet::HttpRet(const HttpRet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HttpRet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.headers_)*/{}
    , decltype(_impl_.method_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.http_version_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_method().empty()) {
    _this->_impl_.method_.Set(from._internal_method(), 
      _this->GetArenaForAllocation());
  }
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.http_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.http_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_http_version().empty()) {
    _this->_impl_.http_version_.Set(from._internal_http_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body().empty()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.HttpRet)
}

inline void HttpRet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.headers_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.method_){}
    , decltype(_impl_.path_){}
    , decltype(_impl_.http_version_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.method_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.method_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.http_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.http_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HttpRet::~HttpRet() {
  // @@protoc_insertion_point(destructor:Protocol.HttpRet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void HttpRet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.Destruct();
  _impl_.headers_.~MapField();
  _impl_.method_.Destroy();
  _impl_.path_.Destroy();
  _impl_.http_version_.Destroy();
  _impl_.body_.Destroy();
}

void HttpRet::ArenaDtor(void* object) {
  HttpRet* _this = reinterpret_cast< HttpRet* >(object);
  _this->_impl_.headers_.Destruct();
}
void HttpRet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HttpRet::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.HttpRet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  _impl_.method_.ClearToEmpty();
  _impl_.path_.ClearToEmpty();
  _impl_.http_version_.ClearToEmpty();
  _impl_.body_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HttpRet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> headers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.headers_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string method = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_method();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRet.method"));
        } else
          goto handle_unusual;
        continue;
      // string path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRet.path"));
        } else
          goto handle_unusual;
        continue;
      // string http_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_http_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRet.http_version"));
        } else
          goto handle_unusual;
        continue;
      // string body = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRet.body"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HttpRet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.HttpRet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> headers = 1;
  if (!this->_internal_headers().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = HttpRet_HeadersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_headers();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Protocol.HttpRet.HeadersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Protocol.HttpRet.HeadersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string method = 2;
  if (!this->_internal_method().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_method().data(), static_cast<int>(this->_internal_method().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRet.method");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_method(), target);
  }

  // string path = 3;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRet.path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_path(), target);
  }

  // string http_version = 4;
  if (!this->_internal_http_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_http_version().data(), static_cast<int>(this->_internal_http_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRet.http_version");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_http_version(), target);
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_body().data(), static_cast<int>(this->_internal_body().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRet.body");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.HttpRet)
  return target;
}

size_t HttpRet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.HttpRet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> headers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_headers_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_headers().begin();
      it != this->_internal_headers().end(); ++it) {
    total_size += HttpRet_HeadersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string method = 2;
  if (!this->_internal_method().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_method());
  }

  // string path = 3;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  // string http_version = 4;
  if (!this->_internal_http_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_http_version());
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_body());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HttpRet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HttpRet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HttpRet::GetClassData() const { return &_class_data_; }


void HttpRet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HttpRet*>(&to_msg);
  auto& from = static_cast<const HttpRet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.HttpRet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  if (!from._internal_method().empty()) {
    _this->_internal_set_method(from._internal_method());
  }
  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  if (!from._internal_http_version().empty()) {
    _this->_internal_set_http_version(from._internal_http_version());
  }
  if (!from._internal_body().empty()) {
    _this->_internal_set_body(from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HttpRet::CopyFrom(const HttpRet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.HttpRet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HttpRet::IsInitialized() const {
  return true;
}

void HttpRet::InternalSwap(HttpRet* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.method_, lhs_arena,
      &other->_impl_.method_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.http_version_, lhs_arena,
      &other->_impl_.http_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HttpRet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[7]);
}

// ===================================================================

HttpRes_HeadersEntry_DoNotUse::HttpRes_HeadersEntry_DoNotUse() {}
HttpRes_HeadersEntry_DoNotUse::HttpRes_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void HttpRes_HeadersEntry_DoNotUse::MergeFrom(const HttpRes_HeadersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata HttpRes_HeadersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[8]);
}

// ===================================================================

class HttpRes::_Internal {
 public:
};

HttpRes::HttpRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &HttpRes::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:Protocol.HttpRes)
}
HttpRes::HttpRes(const HttpRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HttpRes* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.headers_)*/{}
    , decltype(_impl_.http_version_){}
    , decltype(_impl_.status_code_){}
    , decltype(_impl_.phrase_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  _impl_.http_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.http_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_http_version().empty()) {
    _this->_impl_.http_version_.Set(from._internal_http_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.status_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_status_code().empty()) {
    _this->_impl_.status_code_.Set(from._internal_status_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.phrase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phrase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_phrase().empty()) {
    _this->_impl_.phrase_.Set(from._internal_phrase(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_body().empty()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Protocol.HttpRes)
}

inline void HttpRes::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.headers_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.http_version_){}
    , decltype(_impl_.status_code_){}
    , decltype(_impl_.phrase_){}
    , decltype(_impl_.body_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.http_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.http_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.status_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.status_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phrase_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phrase_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HttpRes::~HttpRes() {
  // @@protoc_insertion_point(destructor:Protocol.HttpRes)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void HttpRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.Destruct();
  _impl_.headers_.~MapField();
  _impl_.http_version_.Destroy();
  _impl_.status_code_.Destroy();
  _impl_.phrase_.Destroy();
  _impl_.body_.Destroy();
}

void HttpRes::ArenaDtor(void* object) {
  HttpRes* _this = reinterpret_cast< HttpRes* >(object);
  _this->_impl_.headers_.Destruct();
}
void HttpRes::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HttpRes::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.HttpRes)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  _impl_.http_version_.ClearToEmpty();
  _impl_.status_code_.ClearToEmpty();
  _impl_.phrase_.ClearToEmpty();
  _impl_.body_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HttpRes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> headers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.headers_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string http_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_http_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRes.http_version"));
        } else
          goto handle_unusual;
        continue;
      // string status_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_status_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRes.status_code"));
        } else
          goto handle_unusual;
        continue;
      // string phrase = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_phrase();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRes.phrase"));
        } else
          goto handle_unusual;
        continue;
      // string body = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.HttpRes.body"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HttpRes::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.HttpRes)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> headers = 1;
  if (!this->_internal_headers().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = HttpRes_HeadersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_headers();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Protocol.HttpRes.HeadersEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "Protocol.HttpRes.HeadersEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // string http_version = 2;
  if (!this->_internal_http_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_http_version().data(), static_cast<int>(this->_internal_http_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRes.http_version");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_http_version(), target);
  }

  // string status_code = 3;
  if (!this->_internal_status_code().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_status_code().data(), static_cast<int>(this->_internal_status_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRes.status_code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_status_code(), target);
  }

  // string phrase = 4;
  if (!this->_internal_phrase().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_phrase().data(), static_cast<int>(this->_internal_phrase().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRes.phrase");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_phrase(), target);
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_body().data(), static_cast<int>(this->_internal_body().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.HttpRes.body");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.HttpRes)
  return target;
}

size_t HttpRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.HttpRes)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> headers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_headers_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_headers().begin();
      it != this->_internal_headers().end(); ++it) {
    total_size += HttpRes_HeadersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string http_version = 2;
  if (!this->_internal_http_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_http_version());
  }

  // string status_code = 3;
  if (!this->_internal_status_code().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_status_code());
  }

  // string phrase = 4;
  if (!this->_internal_phrase().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_phrase());
  }

  // string body = 5;
  if (!this->_internal_body().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_body());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HttpRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HttpRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HttpRes::GetClassData() const { return &_class_data_; }


void HttpRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HttpRes*>(&to_msg);
  auto& from = static_cast<const HttpRes&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.HttpRes)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  if (!from._internal_http_version().empty()) {
    _this->_internal_set_http_version(from._internal_http_version());
  }
  if (!from._internal_status_code().empty()) {
    _this->_internal_set_status_code(from._internal_status_code());
  }
  if (!from._internal_phrase().empty()) {
    _this->_internal_set_phrase(from._internal_phrase());
  }
  if (!from._internal_body().empty()) {
    _this->_internal_set_body(from._internal_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HttpRes::CopyFrom(const HttpRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.HttpRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HttpRes::IsInitialized() const {
  return true;
}

void HttpRes::InternalSwap(HttpRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.http_version_, lhs_arena,
      &other->_impl_.http_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.status_code_, lhs_arena,
      &other->_impl_.status_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phrase_, lhs_arena,
      &other->_impl_.phrase_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata HttpRes::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[9]);
}

// ===================================================================

class ProtocolData::_Internal {
 public:
  static const ::Protocol::Ethernet& eth(const ProtocolData* msg);
  static const ::Protocol::Arp& arp(const ProtocolData* msg);
  static const ::Protocol::Ip& ip(const ProtocolData* msg);
  static const ::Protocol::Udp& udp(const ProtocolData* msg);
  static const ::Protocol::Dns& dns(const ProtocolData* msg);
  static const ::Protocol::Tcp& tcp(const ProtocolData* msg);
  static const ::Protocol::HttpRet& http_request(const ProtocolData* msg);
  static const ::Protocol::HttpRes& http_response(const ProtocolData* msg);
};

const ::Protocol::Ethernet&
ProtocolData::_Internal::eth(const ProtocolData* msg) {
  return *msg->_impl_.eth_;
}
const ::Protocol::Arp&
ProtocolData::_Internal::arp(const ProtocolData* msg) {
  return *msg->_impl_.arp_;
}
const ::Protocol::Ip&
ProtocolData::_Internal::ip(const ProtocolData* msg) {
  return *msg->_impl_.ip_;
}
const ::Protocol::Udp&
ProtocolData::_Internal::udp(const ProtocolData* msg) {
  return *msg->_impl_.udp_;
}
const ::Protocol::Dns&
ProtocolData::_Internal::dns(const ProtocolData* msg) {
  return *msg->_impl_.dns_;
}
const ::Protocol::Tcp&
ProtocolData::_Internal::tcp(const ProtocolData* msg) {
  return *msg->_impl_.tcp_;
}
const ::Protocol::HttpRet&
ProtocolData::_Internal::http_request(const ProtocolData* msg) {
  return *msg->_impl_.http_request_;
}
const ::Protocol::HttpRes&
ProtocolData::_Internal::http_response(const ProtocolData* msg) {
  return *msg->_impl_.http_response_;
}
ProtocolData::ProtocolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Protocol.ProtocolData)
}
ProtocolData::ProtocolData(const ProtocolData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtocolData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){}
    , decltype(_impl_.eth_){nullptr}
    , decltype(_impl_.arp_){nullptr}
    , decltype(_impl_.ip_){nullptr}
    , decltype(_impl_.udp_){nullptr}
    , decltype(_impl_.dns_){nullptr}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.http_request_){nullptr}
    , decltype(_impl_.http_response_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.caplen_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_time().empty()) {
    _this->_impl_.time_.Set(from._internal_time(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_eth()) {
    _this->_impl_.eth_ = new ::Protocol::Ethernet(*from._impl_.eth_);
  }
  if (from._internal_has_arp()) {
    _this->_impl_.arp_ = new ::Protocol::Arp(*from._impl_.arp_);
  }
  if (from._internal_has_ip()) {
    _this->_impl_.ip_ = new ::Protocol::Ip(*from._impl_.ip_);
  }
  if (from._internal_has_udp()) {
    _this->_impl_.udp_ = new ::Protocol::Udp(*from._impl_.udp_);
  }
  if (from._internal_has_dns()) {
    _this->_impl_.dns_ = new ::Protocol::Dns(*from._impl_.dns_);
  }
  if (from._internal_has_tcp()) {
    _this->_impl_.tcp_ = new ::Protocol::Tcp(*from._impl_.tcp_);
  }
  if (from._internal_has_http_request()) {
    _this->_impl_.http_request_ = new ::Protocol::HttpRet(*from._impl_.http_request_);
  }
  if (from._internal_has_http_response()) {
    _this->_impl_.http_response_ = new ::Protocol::HttpRes(*from._impl_.http_response_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.caplen_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.caplen_));
  // @@protoc_insertion_point(copy_constructor:Protocol.ProtocolData)
}

inline void ProtocolData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.time_){}
    , decltype(_impl_.eth_){nullptr}
    , decltype(_impl_.arp_){nullptr}
    , decltype(_impl_.ip_){nullptr}
    , decltype(_impl_.udp_){nullptr}
    , decltype(_impl_.dns_){nullptr}
    , decltype(_impl_.tcp_){nullptr}
    , decltype(_impl_.http_request_){nullptr}
    , decltype(_impl_.http_response_){nullptr}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.caplen_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ProtocolData::~ProtocolData() {
  // @@protoc_insertion_point(destructor:Protocol.ProtocolData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtocolData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.time_.Destroy();
  if (this != internal_default_instance()) delete _impl_.eth_;
  if (this != internal_default_instance()) delete _impl_.arp_;
  if (this != internal_default_instance()) delete _impl_.ip_;
  if (this != internal_default_instance()) delete _impl_.udp_;
  if (this != internal_default_instance()) delete _impl_.dns_;
  if (this != internal_default_instance()) delete _impl_.tcp_;
  if (this != internal_default_instance()) delete _impl_.http_request_;
  if (this != internal_default_instance()) delete _impl_.http_response_;
}

void ProtocolData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtocolData::Clear() {
// @@protoc_insertion_point(message_clear_start:Protocol.ProtocolData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.eth_ != nullptr) {
    delete _impl_.eth_;
  }
  _impl_.eth_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.arp_ != nullptr) {
    delete _impl_.arp_;
  }
  _impl_.arp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.ip_ != nullptr) {
    delete _impl_.ip_;
  }
  _impl_.ip_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.udp_ != nullptr) {
    delete _impl_.udp_;
  }
  _impl_.udp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dns_ != nullptr) {
    delete _impl_.dns_;
  }
  _impl_.dns_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.tcp_ != nullptr) {
    delete _impl_.tcp_;
  }
  _impl_.tcp_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.http_request_ != nullptr) {
    delete _impl_.http_request_;
  }
  _impl_.http_request_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.http_response_ != nullptr) {
    delete _impl_.http_response_;
  }
  _impl_.http_response_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.caplen_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.caplen_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtocolData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Protocol.Ethernet eth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_eth(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.Arp arp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_arp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.Ip ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.Udp udp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_udp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.Dns dns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_dns(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.Tcp tcp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_tcp(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.HttpRet http_request = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_http_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Protocol.HttpRes http_response = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_http_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Protocol.ProtocolData.time"));
        } else
          goto handle_unusual;
        continue;
      // uint32 caplen = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.caplen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtocolData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Protocol.ProtocolData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Protocol.Ethernet eth = 1;
  if (this->_internal_has_eth()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::eth(this),
        _Internal::eth(this).GetCachedSize(), target, stream);
  }

  // .Protocol.Arp arp = 2;
  if (this->_internal_has_arp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::arp(this),
        _Internal::arp(this).GetCachedSize(), target, stream);
  }

  // .Protocol.Ip ip = 3;
  if (this->_internal_has_ip()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ip(this),
        _Internal::ip(this).GetCachedSize(), target, stream);
  }

  // .Protocol.Udp udp = 4;
  if (this->_internal_has_udp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::udp(this),
        _Internal::udp(this).GetCachedSize(), target, stream);
  }

  // .Protocol.Dns dns = 5;
  if (this->_internal_has_dns()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::dns(this),
        _Internal::dns(this).GetCachedSize(), target, stream);
  }

  // .Protocol.Tcp tcp = 6;
  if (this->_internal_has_tcp()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::tcp(this),
        _Internal::tcp(this).GetCachedSize(), target, stream);
  }

  // .Protocol.HttpRet http_request = 7;
  if (this->_internal_has_http_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::http_request(this),
        _Internal::http_request(this).GetCachedSize(), target, stream);
  }

  // .Protocol.HttpRes http_response = 8;
  if (this->_internal_has_http_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::http_response(this),
        _Internal::http_response(this).GetCachedSize(), target, stream);
  }

  // uint32 type = 9;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_type(), target);
  }

  // string time = 10;
  if (!this->_internal_time().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_time().data(), static_cast<int>(this->_internal_time().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Protocol.ProtocolData.time");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_time(), target);
  }

  // uint32 caplen = 11;
  if (this->_internal_caplen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_caplen(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Protocol.ProtocolData)
  return target;
}

size_t ProtocolData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Protocol.ProtocolData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string time = 10;
  if (!this->_internal_time().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_time());
  }

  // .Protocol.Ethernet eth = 1;
  if (this->_internal_has_eth()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.eth_);
  }

  // .Protocol.Arp arp = 2;
  if (this->_internal_has_arp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.arp_);
  }

  // .Protocol.Ip ip = 3;
  if (this->_internal_has_ip()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.ip_);
  }

  // .Protocol.Udp udp = 4;
  if (this->_internal_has_udp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.udp_);
  }

  // .Protocol.Dns dns = 5;
  if (this->_internal_has_dns()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dns_);
  }

  // .Protocol.Tcp tcp = 6;
  if (this->_internal_has_tcp()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tcp_);
  }

  // .Protocol.HttpRet http_request = 7;
  if (this->_internal_has_http_request()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.http_request_);
  }

  // .Protocol.HttpRes http_response = 8;
  if (this->_internal_has_http_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.http_response_);
  }

  // uint32 type = 9;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  // uint32 caplen = 11;
  if (this->_internal_caplen() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_caplen());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtocolData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtocolData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtocolData::GetClassData() const { return &_class_data_; }


void ProtocolData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtocolData*>(&to_msg);
  auto& from = static_cast<const ProtocolData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Protocol.ProtocolData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_time().empty()) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_has_eth()) {
    _this->_internal_mutable_eth()->::Protocol::Ethernet::MergeFrom(
        from._internal_eth());
  }
  if (from._internal_has_arp()) {
    _this->_internal_mutable_arp()->::Protocol::Arp::MergeFrom(
        from._internal_arp());
  }
  if (from._internal_has_ip()) {
    _this->_internal_mutable_ip()->::Protocol::Ip::MergeFrom(
        from._internal_ip());
  }
  if (from._internal_has_udp()) {
    _this->_internal_mutable_udp()->::Protocol::Udp::MergeFrom(
        from._internal_udp());
  }
  if (from._internal_has_dns()) {
    _this->_internal_mutable_dns()->::Protocol::Dns::MergeFrom(
        from._internal_dns());
  }
  if (from._internal_has_tcp()) {
    _this->_internal_mutable_tcp()->::Protocol::Tcp::MergeFrom(
        from._internal_tcp());
  }
  if (from._internal_has_http_request()) {
    _this->_internal_mutable_http_request()->::Protocol::HttpRet::MergeFrom(
        from._internal_http_request());
  }
  if (from._internal_has_http_response()) {
    _this->_internal_mutable_http_response()->::Protocol::HttpRes::MergeFrom(
        from._internal_http_response());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_caplen() != 0) {
    _this->_internal_set_caplen(from._internal_caplen());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtocolData::CopyFrom(const ProtocolData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Protocol.ProtocolData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolData::IsInitialized() const {
  return true;
}

void ProtocolData::InternalSwap(ProtocolData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_, lhs_arena,
      &other->_impl_.time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtocolData, _impl_.caplen_)
      + sizeof(ProtocolData::_impl_.caplen_)
      - PROTOBUF_FIELD_OFFSET(ProtocolData, _impl_.eth_)>(
          reinterpret_cast<char*>(&_impl_.eth_),
          reinterpret_cast<char*>(&other->_impl_.eth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtocolData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_data_2eproto_getter, &descriptor_table_data_2eproto_once,
      file_level_metadata_data_2eproto[10]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Protocol::Ethernet*
Arena::CreateMaybeMessage< ::Protocol::Ethernet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Ethernet >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::Arp*
Arena::CreateMaybeMessage< ::Protocol::Arp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Arp >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::Ip*
Arena::CreateMaybeMessage< ::Protocol::Ip >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Ip >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::Udp*
Arena::CreateMaybeMessage< ::Protocol::Udp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Udp >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::Dns*
Arena::CreateMaybeMessage< ::Protocol::Dns >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Dns >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::Tcp*
Arena::CreateMaybeMessage< ::Protocol::Tcp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::Tcp >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::HttpRet_HeadersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Protocol::HttpRet_HeadersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::HttpRet_HeadersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::HttpRet*
Arena::CreateMaybeMessage< ::Protocol::HttpRet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::HttpRet >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::HttpRes_HeadersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::Protocol::HttpRes_HeadersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::HttpRes_HeadersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::HttpRes*
Arena::CreateMaybeMessage< ::Protocol::HttpRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::HttpRes >(arena);
}
template<> PROTOBUF_NOINLINE ::Protocol::ProtocolData*
Arena::CreateMaybeMessage< ::Protocol::ProtocolData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Protocol::ProtocolData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
