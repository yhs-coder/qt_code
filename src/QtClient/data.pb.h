// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_data_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_data_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_data_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_data_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_data_2eproto;
namespace Protocol {
class Arp;
struct ArpDefaultTypeInternal;
extern ArpDefaultTypeInternal _Arp_default_instance_;
class Dns;
struct DnsDefaultTypeInternal;
extern DnsDefaultTypeInternal _Dns_default_instance_;
class Ethernet;
struct EthernetDefaultTypeInternal;
extern EthernetDefaultTypeInternal _Ethernet_default_instance_;
class HttpRes;
struct HttpResDefaultTypeInternal;
extern HttpResDefaultTypeInternal _HttpRes_default_instance_;
class HttpRes_HeadersEntry_DoNotUse;
struct HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal;
extern HttpRes_HeadersEntry_DoNotUseDefaultTypeInternal _HttpRes_HeadersEntry_DoNotUse_default_instance_;
class HttpRet;
struct HttpRetDefaultTypeInternal;
extern HttpRetDefaultTypeInternal _HttpRet_default_instance_;
class HttpRet_HeadersEntry_DoNotUse;
struct HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal;
extern HttpRet_HeadersEntry_DoNotUseDefaultTypeInternal _HttpRet_HeadersEntry_DoNotUse_default_instance_;
class Ip;
struct IpDefaultTypeInternal;
extern IpDefaultTypeInternal _Ip_default_instance_;
class ProtocolData;
struct ProtocolDataDefaultTypeInternal;
extern ProtocolDataDefaultTypeInternal _ProtocolData_default_instance_;
class Tcp;
struct TcpDefaultTypeInternal;
extern TcpDefaultTypeInternal _Tcp_default_instance_;
class Udp;
struct UdpDefaultTypeInternal;
extern UdpDefaultTypeInternal _Udp_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::Arp* Arena::CreateMaybeMessage<::Protocol::Arp>(Arena*);
template<> ::Protocol::Dns* Arena::CreateMaybeMessage<::Protocol::Dns>(Arena*);
template<> ::Protocol::Ethernet* Arena::CreateMaybeMessage<::Protocol::Ethernet>(Arena*);
template<> ::Protocol::HttpRes* Arena::CreateMaybeMessage<::Protocol::HttpRes>(Arena*);
template<> ::Protocol::HttpRes_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::Protocol::HttpRes_HeadersEntry_DoNotUse>(Arena*);
template<> ::Protocol::HttpRet* Arena::CreateMaybeMessage<::Protocol::HttpRet>(Arena*);
template<> ::Protocol::HttpRet_HeadersEntry_DoNotUse* Arena::CreateMaybeMessage<::Protocol::HttpRet_HeadersEntry_DoNotUse>(Arena*);
template<> ::Protocol::Ip* Arena::CreateMaybeMessage<::Protocol::Ip>(Arena*);
template<> ::Protocol::ProtocolData* Arena::CreateMaybeMessage<::Protocol::ProtocolData>(Arena*);
template<> ::Protocol::Tcp* Arena::CreateMaybeMessage<::Protocol::Tcp>(Arena*);
template<> ::Protocol::Udp* Arena::CreateMaybeMessage<::Protocol::Udp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class Ethernet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Ethernet) */ {
 public:
  inline Ethernet() : Ethernet(nullptr) {}
  ~Ethernet() override;
  explicit PROTOBUF_CONSTEXPR Ethernet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ethernet(const Ethernet& from);
  Ethernet(Ethernet&& from) noexcept
    : Ethernet() {
    *this = ::std::move(from);
  }

  inline Ethernet& operator=(const Ethernet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ethernet& operator=(Ethernet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ethernet& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ethernet* internal_default_instance() {
    return reinterpret_cast<const Ethernet*>(
               &_Ethernet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Ethernet& a, Ethernet& b) {
    a.Swap(&b);
  }
  inline void Swap(Ethernet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ethernet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ethernet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ethernet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ethernet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ethernet& from) {
    Ethernet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ethernet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Ethernet";
  }
  protected:
  explicit Ethernet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstFieldNumber = 1,
    kSrcFieldNumber = 2,
  };
  // string dst = 1;
  void clear_dst();
  const std::string& dst() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst();
  PROTOBUF_NODISCARD std::string* release_dst();
  void set_allocated_dst(std::string* dst);
  private:
  const std::string& _internal_dst() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst(const std::string& value);
  std::string* _internal_mutable_dst();
  public:

  // string src = 2;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Ethernet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Arp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Arp) */ {
 public:
  inline Arp() : Arp(nullptr) {}
  ~Arp() override;
  explicit PROTOBUF_CONSTEXPR Arp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Arp(const Arp& from);
  Arp(Arp&& from) noexcept
    : Arp() {
    *this = ::std::move(from);
  }

  inline Arp& operator=(const Arp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Arp& operator=(Arp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Arp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Arp* internal_default_instance() {
    return reinterpret_cast<const Arp*>(
               &_Arp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Arp& a, Arp& b) {
    a.Swap(&b);
  }
  inline void Swap(Arp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Arp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Arp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Arp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Arp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Arp& from) {
    Arp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Arp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Arp";
  }
  protected:
  explicit Arp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceMacFieldNumber = 6,
    kSourceIpFieldNumber = 7,
    kTargetMacFieldNumber = 8,
    kTargetIpFieldNumber = 9,
    kHardwareTypeFieldNumber = 1,
    kProtocolTypeFieldNumber = 2,
    kHardwareSizeFieldNumber = 3,
    kProtocolSizeFieldNumber = 4,
    kOpTypeFieldNumber = 5,
  };
  // string source_mac = 6;
  void clear_source_mac();
  const std::string& source_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_mac();
  PROTOBUF_NODISCARD std::string* release_source_mac();
  void set_allocated_source_mac(std::string* source_mac);
  private:
  const std::string& _internal_source_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_mac(const std::string& value);
  std::string* _internal_mutable_source_mac();
  public:

  // string source_ip = 7;
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // string target_mac = 8;
  void clear_target_mac();
  const std::string& target_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_mac();
  PROTOBUF_NODISCARD std::string* release_target_mac();
  void set_allocated_target_mac(std::string* target_mac);
  private:
  const std::string& _internal_target_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_mac(const std::string& value);
  std::string* _internal_mutable_target_mac();
  public:

  // string target_ip = 9;
  void clear_target_ip();
  const std::string& target_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_ip();
  PROTOBUF_NODISCARD std::string* release_target_ip();
  void set_allocated_target_ip(std::string* target_ip);
  private:
  const std::string& _internal_target_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_ip(const std::string& value);
  std::string* _internal_mutable_target_ip();
  public:

  // uint32 hardware_type = 1;
  void clear_hardware_type();
  uint32_t hardware_type() const;
  void set_hardware_type(uint32_t value);
  private:
  uint32_t _internal_hardware_type() const;
  void _internal_set_hardware_type(uint32_t value);
  public:

  // uint32 protocol_type = 2;
  void clear_protocol_type();
  uint32_t protocol_type() const;
  void set_protocol_type(uint32_t value);
  private:
  uint32_t _internal_protocol_type() const;
  void _internal_set_protocol_type(uint32_t value);
  public:

  // uint32 hardware_size = 3;
  void clear_hardware_size();
  uint32_t hardware_size() const;
  void set_hardware_size(uint32_t value);
  private:
  uint32_t _internal_hardware_size() const;
  void _internal_set_hardware_size(uint32_t value);
  public:

  // uint32 protocol_size = 4;
  void clear_protocol_size();
  uint32_t protocol_size() const;
  void set_protocol_size(uint32_t value);
  private:
  uint32_t _internal_protocol_size() const;
  void _internal_set_protocol_size(uint32_t value);
  public:

  // uint32 op_type = 5;
  void clear_op_type();
  uint32_t op_type() const;
  void set_op_type(uint32_t value);
  private:
  uint32_t _internal_op_type() const;
  void _internal_set_op_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Arp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_ip_;
    uint32_t hardware_type_;
    uint32_t protocol_type_;
    uint32_t hardware_size_;
    uint32_t protocol_size_;
    uint32_t op_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Ip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Ip) */ {
 public:
  inline Ip() : Ip(nullptr) {}
  ~Ip() override;
  explicit PROTOBUF_CONSTEXPR Ip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ip(const Ip& from);
  Ip(Ip&& from) noexcept
    : Ip() {
    *this = ::std::move(from);
  }

  inline Ip& operator=(const Ip& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ip& operator=(Ip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ip& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ip* internal_default_instance() {
    return reinterpret_cast<const Ip*>(
               &_Ip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ip& a, Ip& b) {
    a.Swap(&b);
  }
  inline void Swap(Ip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ip& from) {
    Ip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Ip";
  }
  protected:
  explicit Ip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIpFieldNumber = 11,
    kTargetIpFieldNumber = 12,
    kVersionFieldNumber = 1,
    kHeaderLenFieldNumber = 2,
    kServiceTypeFieldNumber = 3,
    kTotalLenFieldNumber = 4,
    kIdentificationFieldNumber = 5,
    kFlagsFieldNumber = 6,
    kFragmentOffsetFieldNumber = 7,
    kTtlFieldNumber = 8,
    kProtocolFieldNumber = 9,
    kChecksumFieldNumber = 10,
  };
  // string source_ip = 11;
  void clear_source_ip();
  const std::string& source_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_ip();
  PROTOBUF_NODISCARD std::string* release_source_ip();
  void set_allocated_source_ip(std::string* source_ip);
  private:
  const std::string& _internal_source_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_ip(const std::string& value);
  std::string* _internal_mutable_source_ip();
  public:

  // string target_ip = 12;
  void clear_target_ip();
  const std::string& target_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_ip();
  PROTOBUF_NODISCARD std::string* release_target_ip();
  void set_allocated_target_ip(std::string* target_ip);
  private:
  const std::string& _internal_target_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_ip(const std::string& value);
  std::string* _internal_mutable_target_ip();
  public:

  // uint32 version = 1;
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // uint32 header_len = 2;
  void clear_header_len();
  uint32_t header_len() const;
  void set_header_len(uint32_t value);
  private:
  uint32_t _internal_header_len() const;
  void _internal_set_header_len(uint32_t value);
  public:

  // uint32 service_type = 3;
  void clear_service_type();
  uint32_t service_type() const;
  void set_service_type(uint32_t value);
  private:
  uint32_t _internal_service_type() const;
  void _internal_set_service_type(uint32_t value);
  public:

  // uint32 total_len = 4;
  void clear_total_len();
  uint32_t total_len() const;
  void set_total_len(uint32_t value);
  private:
  uint32_t _internal_total_len() const;
  void _internal_set_total_len(uint32_t value);
  public:

  // uint32 identification = 5;
  void clear_identification();
  uint32_t identification() const;
  void set_identification(uint32_t value);
  private:
  uint32_t _internal_identification() const;
  void _internal_set_identification(uint32_t value);
  public:

  // uint32 flags = 6;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // uint32 fragment_offset = 7;
  void clear_fragment_offset();
  uint32_t fragment_offset() const;
  void set_fragment_offset(uint32_t value);
  private:
  uint32_t _internal_fragment_offset() const;
  void _internal_set_fragment_offset(uint32_t value);
  public:

  // uint32 ttl = 8;
  void clear_ttl();
  uint32_t ttl() const;
  void set_ttl(uint32_t value);
  private:
  uint32_t _internal_ttl() const;
  void _internal_set_ttl(uint32_t value);
  public:

  // uint32 protocol = 9;
  void clear_protocol();
  uint32_t protocol() const;
  void set_protocol(uint32_t value);
  private:
  uint32_t _internal_protocol() const;
  void _internal_set_protocol(uint32_t value);
  public:

  // uint32 checksum = 10;
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Ip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_ip_;
    uint32_t version_;
    uint32_t header_len_;
    uint32_t service_type_;
    uint32_t total_len_;
    uint32_t identification_;
    uint32_t flags_;
    uint32_t fragment_offset_;
    uint32_t ttl_;
    uint32_t protocol_;
    uint32_t checksum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Udp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Udp) */ {
 public:
  inline Udp() : Udp(nullptr) {}
  ~Udp() override;
  explicit PROTOBUF_CONSTEXPR Udp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Udp(const Udp& from);
  Udp(Udp&& from) noexcept
    : Udp() {
    *this = ::std::move(from);
  }

  inline Udp& operator=(const Udp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Udp& operator=(Udp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Udp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Udp* internal_default_instance() {
    return reinterpret_cast<const Udp*>(
               &_Udp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Udp& a, Udp& b) {
    a.Swap(&b);
  }
  inline void Swap(Udp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Udp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Udp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Udp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Udp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Udp& from) {
    Udp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Udp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Udp";
  }
  protected:
  explicit Udp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePortFieldNumber = 1,
    kTargetPortFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
    kCheckSumFieldNumber = 4,
  };
  // uint32 source_port = 1;
  void clear_source_port();
  uint32_t source_port() const;
  void set_source_port(uint32_t value);
  private:
  uint32_t _internal_source_port() const;
  void _internal_set_source_port(uint32_t value);
  public:

  // uint32 target_port = 2;
  void clear_target_port();
  uint32_t target_port() const;
  void set_target_port(uint32_t value);
  private:
  uint32_t _internal_target_port() const;
  void _internal_set_target_port(uint32_t value);
  public:

  // uint32 total_size = 3;
  void clear_total_size();
  uint32_t total_size() const;
  void set_total_size(uint32_t value);
  private:
  uint32_t _internal_total_size() const;
  void _internal_set_total_size(uint32_t value);
  public:

  // uint32 check_sum = 4;
  void clear_check_sum();
  uint32_t check_sum() const;
  void set_check_sum(uint32_t value);
  private:
  uint32_t _internal_check_sum() const;
  void _internal_set_check_sum(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Udp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t source_port_;
    uint32_t target_port_;
    uint32_t total_size_;
    uint32_t check_sum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Dns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Dns) */ {
 public:
  inline Dns() : Dns(nullptr) {}
  ~Dns() override;
  explicit PROTOBUF_CONSTEXPR Dns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dns(const Dns& from);
  Dns(Dns&& from) noexcept
    : Dns() {
    *this = ::std::move(from);
  }

  inline Dns& operator=(const Dns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dns& operator=(Dns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dns* internal_default_instance() {
    return reinterpret_cast<const Dns*>(
               &_Dns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Dns& a, Dns& b) {
    a.Swap(&b);
  }
  inline void Swap(Dns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dns& from) {
    Dns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Dns";
  }
  protected:
  explicit Dns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdFieldNumber = 1,
    kOpCodeFieldNumber = 3,
    kIsResponseFieldNumber = 2,
    kIsAuthenticatedAnswerFieldNumber = 4,
    kIsTruncatedFieldNumber = 5,
    kIsRecursionDesiredFieldNumber = 6,
    kIsRecursionAvailableFieldNumber = 7,
    kReplyCodeFieldNumber = 8,
    kQuestionAmountFieldNumber = 9,
    kAnswerAmountFieldNumber = 10,
    kAuthorityAmountFieldNumber = 11,
    kAdditionalAmountFieldNumber = 12,
  };
  // uint32 transaction_id = 1;
  void clear_transaction_id();
  uint32_t transaction_id() const;
  void set_transaction_id(uint32_t value);
  private:
  uint32_t _internal_transaction_id() const;
  void _internal_set_transaction_id(uint32_t value);
  public:

  // uint32 op_code = 3;
  void clear_op_code();
  uint32_t op_code() const;
  void set_op_code(uint32_t value);
  private:
  uint32_t _internal_op_code() const;
  void _internal_set_op_code(uint32_t value);
  public:

  // bool is_response = 2;
  void clear_is_response();
  bool is_response() const;
  void set_is_response(bool value);
  private:
  bool _internal_is_response() const;
  void _internal_set_is_response(bool value);
  public:

  // bool is_authenticated_answer = 4;
  void clear_is_authenticated_answer();
  bool is_authenticated_answer() const;
  void set_is_authenticated_answer(bool value);
  private:
  bool _internal_is_authenticated_answer() const;
  void _internal_set_is_authenticated_answer(bool value);
  public:

  // bool is_truncated = 5;
  void clear_is_truncated();
  bool is_truncated() const;
  void set_is_truncated(bool value);
  private:
  bool _internal_is_truncated() const;
  void _internal_set_is_truncated(bool value);
  public:

  // bool is_recursion_desired = 6;
  void clear_is_recursion_desired();
  bool is_recursion_desired() const;
  void set_is_recursion_desired(bool value);
  private:
  bool _internal_is_recursion_desired() const;
  void _internal_set_is_recursion_desired(bool value);
  public:

  // bool is_recursion_available = 7;
  void clear_is_recursion_available();
  bool is_recursion_available() const;
  void set_is_recursion_available(bool value);
  private:
  bool _internal_is_recursion_available() const;
  void _internal_set_is_recursion_available(bool value);
  public:

  // uint32 reply_code = 8;
  void clear_reply_code();
  uint32_t reply_code() const;
  void set_reply_code(uint32_t value);
  private:
  uint32_t _internal_reply_code() const;
  void _internal_set_reply_code(uint32_t value);
  public:

  // uint32 question_amount = 9;
  void clear_question_amount();
  uint32_t question_amount() const;
  void set_question_amount(uint32_t value);
  private:
  uint32_t _internal_question_amount() const;
  void _internal_set_question_amount(uint32_t value);
  public:

  // uint32 answer_amount = 10;
  void clear_answer_amount();
  uint32_t answer_amount() const;
  void set_answer_amount(uint32_t value);
  private:
  uint32_t _internal_answer_amount() const;
  void _internal_set_answer_amount(uint32_t value);
  public:

  // uint32 authority_amount = 11;
  void clear_authority_amount();
  uint32_t authority_amount() const;
  void set_authority_amount(uint32_t value);
  private:
  uint32_t _internal_authority_amount() const;
  void _internal_set_authority_amount(uint32_t value);
  public:

  // uint32 additional_amount = 12;
  void clear_additional_amount();
  uint32_t additional_amount() const;
  void set_additional_amount(uint32_t value);
  private:
  uint32_t _internal_additional_amount() const;
  void _internal_set_additional_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Dns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t transaction_id_;
    uint32_t op_code_;
    bool is_response_;
    bool is_authenticated_answer_;
    bool is_truncated_;
    bool is_recursion_desired_;
    bool is_recursion_available_;
    uint32_t reply_code_;
    uint32_t question_amount_;
    uint32_t answer_amount_;
    uint32_t authority_amount_;
    uint32_t additional_amount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class Tcp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Tcp) */ {
 public:
  inline Tcp() : Tcp(nullptr) {}
  ~Tcp() override;
  explicit PROTOBUF_CONSTEXPR Tcp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tcp(const Tcp& from);
  Tcp(Tcp&& from) noexcept
    : Tcp() {
    *this = ::std::move(from);
  }

  inline Tcp& operator=(const Tcp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tcp& operator=(Tcp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tcp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tcp* internal_default_instance() {
    return reinterpret_cast<const Tcp*>(
               &_Tcp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Tcp& a, Tcp& b) {
    a.Swap(&b);
  }
  inline void Swap(Tcp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tcp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tcp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tcp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tcp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tcp& from) {
    Tcp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tcp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Tcp";
  }
  protected:
  explicit Tcp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcePortFieldNumber = 1,
    kTargetPortFieldNumber = 2,
    kSeqNumFieldNumber = 3,
    kAckNumFieldNumber = 4,
    kHeaderLenFieldNumber = 5,
    kReserveFieldNumber = 6,
    kUrgFieldNumber = 7,
    kSynFieldNumber = 8,
    kAckFieldNumber = 9,
    kWindowFieldNumber = 10,
    kChecksumFieldNumber = 11,
    kUrgentPointerFieldNumber = 12,
    kFlagsFieldNumber = 13,
  };
  // uint32 source_port = 1;
  void clear_source_port();
  uint32_t source_port() const;
  void set_source_port(uint32_t value);
  private:
  uint32_t _internal_source_port() const;
  void _internal_set_source_port(uint32_t value);
  public:

  // uint32 target_port = 2;
  void clear_target_port();
  uint32_t target_port() const;
  void set_target_port(uint32_t value);
  private:
  uint32_t _internal_target_port() const;
  void _internal_set_target_port(uint32_t value);
  public:

  // uint32 seq_num = 3;
  void clear_seq_num();
  uint32_t seq_num() const;
  void set_seq_num(uint32_t value);
  private:
  uint32_t _internal_seq_num() const;
  void _internal_set_seq_num(uint32_t value);
  public:

  // uint32 ack_num = 4;
  void clear_ack_num();
  uint32_t ack_num() const;
  void set_ack_num(uint32_t value);
  private:
  uint32_t _internal_ack_num() const;
  void _internal_set_ack_num(uint32_t value);
  public:

  // uint32 header_len = 5;
  void clear_header_len();
  uint32_t header_len() const;
  void set_header_len(uint32_t value);
  private:
  uint32_t _internal_header_len() const;
  void _internal_set_header_len(uint32_t value);
  public:

  // uint32 reserve = 6;
  void clear_reserve();
  uint32_t reserve() const;
  void set_reserve(uint32_t value);
  private:
  uint32_t _internal_reserve() const;
  void _internal_set_reserve(uint32_t value);
  public:

  // bool urg = 7;
  void clear_urg();
  bool urg() const;
  void set_urg(bool value);
  private:
  bool _internal_urg() const;
  void _internal_set_urg(bool value);
  public:

  // bool syn = 8;
  void clear_syn();
  bool syn() const;
  void set_syn(bool value);
  private:
  bool _internal_syn() const;
  void _internal_set_syn(bool value);
  public:

  // bool ack = 9;
  void clear_ack();
  bool ack() const;
  void set_ack(bool value);
  private:
  bool _internal_ack() const;
  void _internal_set_ack(bool value);
  public:

  // uint32 window = 10;
  void clear_window();
  uint32_t window() const;
  void set_window(uint32_t value);
  private:
  uint32_t _internal_window() const;
  void _internal_set_window(uint32_t value);
  public:

  // uint32 checksum = 11;
  void clear_checksum();
  uint32_t checksum() const;
  void set_checksum(uint32_t value);
  private:
  uint32_t _internal_checksum() const;
  void _internal_set_checksum(uint32_t value);
  public:

  // uint32 urgent_pointer = 12;
  void clear_urgent_pointer();
  uint32_t urgent_pointer() const;
  void set_urgent_pointer(uint32_t value);
  private:
  uint32_t _internal_urgent_pointer() const;
  void _internal_set_urgent_pointer(uint32_t value);
  public:

  // uint32 flags = 13;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Tcp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t source_port_;
    uint32_t target_port_;
    uint32_t seq_num_;
    uint32_t ack_num_;
    uint32_t header_len_;
    uint32_t reserve_;
    bool urg_;
    bool syn_;
    bool ack_;
    uint32_t window_;
    uint32_t checksum_;
    uint32_t urgent_pointer_;
    uint32_t flags_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class HttpRet_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HttpRet_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HttpRet_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HttpRet_HeadersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HttpRet_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HttpRet_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HttpRet_HeadersEntry_DoNotUse& other);
  static const HttpRet_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HttpRet_HeadersEntry_DoNotUse*>(&_HttpRet_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Protocol.HttpRet.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Protocol.HttpRet.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_data_2eproto;
};

// -------------------------------------------------------------------

class HttpRet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.HttpRet) */ {
 public:
  inline HttpRet() : HttpRet(nullptr) {}
  ~HttpRet() override;
  explicit PROTOBUF_CONSTEXPR HttpRet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpRet(const HttpRet& from);
  HttpRet(HttpRet&& from) noexcept
    : HttpRet() {
    *this = ::std::move(from);
  }

  inline HttpRet& operator=(const HttpRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRet& operator=(HttpRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpRet* internal_default_instance() {
    return reinterpret_cast<const HttpRet*>(
               &_HttpRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HttpRet& a, HttpRet& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpRet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpRet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpRet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpRet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpRet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HttpRet& from) {
    HttpRet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpRet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.HttpRet";
  }
  protected:
  explicit HttpRet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
    kMethodFieldNumber = 2,
    kPathFieldNumber = 3,
    kHttpVersionFieldNumber = 4,
    kBodyFieldNumber = 5,
  };
  // map<string, string> headers = 1;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string method = 2;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // string path = 3;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // string http_version = 4;
  void clear_http_version();
  const std::string& http_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_http_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_http_version();
  PROTOBUF_NODISCARD std::string* release_http_version();
  void set_allocated_http_version(std::string* http_version);
  private:
  const std::string& _internal_http_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_http_version(const std::string& value);
  std::string* _internal_mutable_http_version();
  public:

  // string body = 5;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.HttpRet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HttpRet_HeadersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr http_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class HttpRes_HeadersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HttpRes_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HttpRes_HeadersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HttpRes_HeadersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HttpRes_HeadersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HttpRes_HeadersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HttpRes_HeadersEntry_DoNotUse& other);
  static const HttpRes_HeadersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HttpRes_HeadersEntry_DoNotUse*>(&_HttpRes_HeadersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Protocol.HttpRes.HeadersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Protocol.HttpRes.HeadersEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_data_2eproto;
};

// -------------------------------------------------------------------

class HttpRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.HttpRes) */ {
 public:
  inline HttpRes() : HttpRes(nullptr) {}
  ~HttpRes() override;
  explicit PROTOBUF_CONSTEXPR HttpRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpRes(const HttpRes& from);
  HttpRes(HttpRes&& from) noexcept
    : HttpRes() {
    *this = ::std::move(from);
  }

  inline HttpRes& operator=(const HttpRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRes& operator=(HttpRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HttpRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpRes* internal_default_instance() {
    return reinterpret_cast<const HttpRes*>(
               &_HttpRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HttpRes& a, HttpRes& b) {
    a.Swap(&b);
  }
  inline void Swap(HttpRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HttpRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HttpRes& from) {
    HttpRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HttpRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.HttpRes";
  }
  protected:
  explicit HttpRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kHeadersFieldNumber = 1,
    kHttpVersionFieldNumber = 2,
    kStatusCodeFieldNumber = 3,
    kPhraseFieldNumber = 4,
    kBodyFieldNumber = 5,
  };
  // map<string, string> headers = 1;
  int headers_size() const;
  private:
  int _internal_headers_size() const;
  public:
  void clear_headers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_headers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      headers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_headers();

  // string http_version = 2;
  void clear_http_version();
  const std::string& http_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_http_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_http_version();
  PROTOBUF_NODISCARD std::string* release_http_version();
  void set_allocated_http_version(std::string* http_version);
  private:
  const std::string& _internal_http_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_http_version(const std::string& value);
  std::string* _internal_mutable_http_version();
  public:

  // string status_code = 3;
  void clear_status_code();
  const std::string& status_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status_code();
  PROTOBUF_NODISCARD std::string* release_status_code();
  void set_allocated_status_code(std::string* status_code);
  private:
  const std::string& _internal_status_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status_code(const std::string& value);
  std::string* _internal_mutable_status_code();
  public:

  // string phrase = 4;
  void clear_phrase();
  const std::string& phrase() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_phrase(ArgT0&& arg0, ArgT... args);
  std::string* mutable_phrase();
  PROTOBUF_NODISCARD std::string* release_phrase();
  void set_allocated_phrase(std::string* phrase);
  private:
  const std::string& _internal_phrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phrase(const std::string& value);
  std::string* _internal_mutable_phrase();
  public:

  // string body = 5;
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.HttpRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HttpRes_HeadersEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> headers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr http_version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phrase_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// -------------------------------------------------------------------

class ProtocolData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ProtocolData) */ {
 public:
  inline ProtocolData() : ProtocolData(nullptr) {}
  ~ProtocolData() override;
  explicit PROTOBUF_CONSTEXPR ProtocolData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolData(const ProtocolData& from);
  ProtocolData(ProtocolData&& from) noexcept
    : ProtocolData() {
    *this = ::std::move(from);
  }

  inline ProtocolData& operator=(const ProtocolData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolData& operator=(ProtocolData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolData* internal_default_instance() {
    return reinterpret_cast<const ProtocolData*>(
               &_ProtocolData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ProtocolData& a, ProtocolData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtocolData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtocolData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtocolData& from) {
    ProtocolData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ProtocolData";
  }
  protected:
  explicit ProtocolData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEthFieldNumber = 1,
    kArpFieldNumber = 2,
    kIpFieldNumber = 3,
    kUdpFieldNumber = 4,
    kDnsFieldNumber = 5,
    kTcpFieldNumber = 6,
    kHttpRequestFieldNumber = 7,
    kHttpResponseFieldNumber = 8,
    kTypeFieldNumber = 9,
  };
  // .Protocol.Ethernet eth = 1;
  bool has_eth() const;
  private:
  bool _internal_has_eth() const;
  public:
  void clear_eth();
  const ::Protocol::Ethernet& eth() const;
  PROTOBUF_NODISCARD ::Protocol::Ethernet* release_eth();
  ::Protocol::Ethernet* mutable_eth();
  void set_allocated_eth(::Protocol::Ethernet* eth);
  private:
  const ::Protocol::Ethernet& _internal_eth() const;
  ::Protocol::Ethernet* _internal_mutable_eth();
  public:
  void unsafe_arena_set_allocated_eth(
      ::Protocol::Ethernet* eth);
  ::Protocol::Ethernet* unsafe_arena_release_eth();

  // .Protocol.Arp arp = 2;
  bool has_arp() const;
  private:
  bool _internal_has_arp() const;
  public:
  void clear_arp();
  const ::Protocol::Arp& arp() const;
  PROTOBUF_NODISCARD ::Protocol::Arp* release_arp();
  ::Protocol::Arp* mutable_arp();
  void set_allocated_arp(::Protocol::Arp* arp);
  private:
  const ::Protocol::Arp& _internal_arp() const;
  ::Protocol::Arp* _internal_mutable_arp();
  public:
  void unsafe_arena_set_allocated_arp(
      ::Protocol::Arp* arp);
  ::Protocol::Arp* unsafe_arena_release_arp();

  // .Protocol.Ip ip = 3;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::Protocol::Ip& ip() const;
  PROTOBUF_NODISCARD ::Protocol::Ip* release_ip();
  ::Protocol::Ip* mutable_ip();
  void set_allocated_ip(::Protocol::Ip* ip);
  private:
  const ::Protocol::Ip& _internal_ip() const;
  ::Protocol::Ip* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::Protocol::Ip* ip);
  ::Protocol::Ip* unsafe_arena_release_ip();

  // .Protocol.Udp udp = 4;
  bool has_udp() const;
  private:
  bool _internal_has_udp() const;
  public:
  void clear_udp();
  const ::Protocol::Udp& udp() const;
  PROTOBUF_NODISCARD ::Protocol::Udp* release_udp();
  ::Protocol::Udp* mutable_udp();
  void set_allocated_udp(::Protocol::Udp* udp);
  private:
  const ::Protocol::Udp& _internal_udp() const;
  ::Protocol::Udp* _internal_mutable_udp();
  public:
  void unsafe_arena_set_allocated_udp(
      ::Protocol::Udp* udp);
  ::Protocol::Udp* unsafe_arena_release_udp();

  // .Protocol.Dns dns = 5;
  bool has_dns() const;
  private:
  bool _internal_has_dns() const;
  public:
  void clear_dns();
  const ::Protocol::Dns& dns() const;
  PROTOBUF_NODISCARD ::Protocol::Dns* release_dns();
  ::Protocol::Dns* mutable_dns();
  void set_allocated_dns(::Protocol::Dns* dns);
  private:
  const ::Protocol::Dns& _internal_dns() const;
  ::Protocol::Dns* _internal_mutable_dns();
  public:
  void unsafe_arena_set_allocated_dns(
      ::Protocol::Dns* dns);
  ::Protocol::Dns* unsafe_arena_release_dns();

  // .Protocol.Tcp tcp = 6;
  bool has_tcp() const;
  private:
  bool _internal_has_tcp() const;
  public:
  void clear_tcp();
  const ::Protocol::Tcp& tcp() const;
  PROTOBUF_NODISCARD ::Protocol::Tcp* release_tcp();
  ::Protocol::Tcp* mutable_tcp();
  void set_allocated_tcp(::Protocol::Tcp* tcp);
  private:
  const ::Protocol::Tcp& _internal_tcp() const;
  ::Protocol::Tcp* _internal_mutable_tcp();
  public:
  void unsafe_arena_set_allocated_tcp(
      ::Protocol::Tcp* tcp);
  ::Protocol::Tcp* unsafe_arena_release_tcp();

  // .Protocol.HttpRet http_request = 7;
  bool has_http_request() const;
  private:
  bool _internal_has_http_request() const;
  public:
  void clear_http_request();
  const ::Protocol::HttpRet& http_request() const;
  PROTOBUF_NODISCARD ::Protocol::HttpRet* release_http_request();
  ::Protocol::HttpRet* mutable_http_request();
  void set_allocated_http_request(::Protocol::HttpRet* http_request);
  private:
  const ::Protocol::HttpRet& _internal_http_request() const;
  ::Protocol::HttpRet* _internal_mutable_http_request();
  public:
  void unsafe_arena_set_allocated_http_request(
      ::Protocol::HttpRet* http_request);
  ::Protocol::HttpRet* unsafe_arena_release_http_request();

  // .Protocol.HttpRes http_response = 8;
  bool has_http_response() const;
  private:
  bool _internal_has_http_response() const;
  public:
  void clear_http_response();
  const ::Protocol::HttpRes& http_response() const;
  PROTOBUF_NODISCARD ::Protocol::HttpRes* release_http_response();
  ::Protocol::HttpRes* mutable_http_response();
  void set_allocated_http_response(::Protocol::HttpRes* http_response);
  private:
  const ::Protocol::HttpRes& _internal_http_response() const;
  ::Protocol::HttpRes* _internal_mutable_http_response();
  public:
  void unsafe_arena_set_allocated_http_response(
      ::Protocol::HttpRes* http_response);
  ::Protocol::HttpRes* unsafe_arena_release_http_response();

  // uint32 type = 9;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ProtocolData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Ethernet* eth_;
    ::Protocol::Arp* arp_;
    ::Protocol::Ip* ip_;
    ::Protocol::Udp* udp_;
    ::Protocol::Dns* dns_;
    ::Protocol::Tcp* tcp_;
    ::Protocol::HttpRet* http_request_;
    ::Protocol::HttpRes* http_response_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_data_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Ethernet

// string dst = 1;
inline void Ethernet::clear_dst() {
  _impl_.dst_.ClearToEmpty();
}
inline const std::string& Ethernet::dst() const {
  // @@protoc_insertion_point(field_get:Protocol.Ethernet.dst)
  return _internal_dst();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ethernet::set_dst(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dst_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Ethernet.dst)
}
inline std::string* Ethernet::mutable_dst() {
  std::string* _s = _internal_mutable_dst();
  // @@protoc_insertion_point(field_mutable:Protocol.Ethernet.dst)
  return _s;
}
inline const std::string& Ethernet::_internal_dst() const {
  return _impl_.dst_.Get();
}
inline void Ethernet::_internal_set_dst(const std::string& value) {
  
  _impl_.dst_.Set(value, GetArenaForAllocation());
}
inline std::string* Ethernet::_internal_mutable_dst() {
  
  return _impl_.dst_.Mutable(GetArenaForAllocation());
}
inline std::string* Ethernet::release_dst() {
  // @@protoc_insertion_point(field_release:Protocol.Ethernet.dst)
  return _impl_.dst_.Release();
}
inline void Ethernet::set_allocated_dst(std::string* dst) {
  if (dst != nullptr) {
    
  } else {
    
  }
  _impl_.dst_.SetAllocated(dst, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dst_.IsDefault()) {
    _impl_.dst_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Ethernet.dst)
}

// string src = 2;
inline void Ethernet::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& Ethernet::src() const {
  // @@protoc_insertion_point(field_get:Protocol.Ethernet.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ethernet::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Ethernet.src)
}
inline std::string* Ethernet::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:Protocol.Ethernet.src)
  return _s;
}
inline const std::string& Ethernet::_internal_src() const {
  return _impl_.src_.Get();
}
inline void Ethernet::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* Ethernet::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* Ethernet::release_src() {
  // @@protoc_insertion_point(field_release:Protocol.Ethernet.src)
  return _impl_.src_.Release();
}
inline void Ethernet::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Ethernet.src)
}

// -------------------------------------------------------------------

// Arp

// uint32 hardware_type = 1;
inline void Arp::clear_hardware_type() {
  _impl_.hardware_type_ = 0u;
}
inline uint32_t Arp::_internal_hardware_type() const {
  return _impl_.hardware_type_;
}
inline uint32_t Arp::hardware_type() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.hardware_type)
  return _internal_hardware_type();
}
inline void Arp::_internal_set_hardware_type(uint32_t value) {
  
  _impl_.hardware_type_ = value;
}
inline void Arp::set_hardware_type(uint32_t value) {
  _internal_set_hardware_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Arp.hardware_type)
}

// uint32 protocol_type = 2;
inline void Arp::clear_protocol_type() {
  _impl_.protocol_type_ = 0u;
}
inline uint32_t Arp::_internal_protocol_type() const {
  return _impl_.protocol_type_;
}
inline uint32_t Arp::protocol_type() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.protocol_type)
  return _internal_protocol_type();
}
inline void Arp::_internal_set_protocol_type(uint32_t value) {
  
  _impl_.protocol_type_ = value;
}
inline void Arp::set_protocol_type(uint32_t value) {
  _internal_set_protocol_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Arp.protocol_type)
}

// uint32 hardware_size = 3;
inline void Arp::clear_hardware_size() {
  _impl_.hardware_size_ = 0u;
}
inline uint32_t Arp::_internal_hardware_size() const {
  return _impl_.hardware_size_;
}
inline uint32_t Arp::hardware_size() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.hardware_size)
  return _internal_hardware_size();
}
inline void Arp::_internal_set_hardware_size(uint32_t value) {
  
  _impl_.hardware_size_ = value;
}
inline void Arp::set_hardware_size(uint32_t value) {
  _internal_set_hardware_size(value);
  // @@protoc_insertion_point(field_set:Protocol.Arp.hardware_size)
}

// uint32 protocol_size = 4;
inline void Arp::clear_protocol_size() {
  _impl_.protocol_size_ = 0u;
}
inline uint32_t Arp::_internal_protocol_size() const {
  return _impl_.protocol_size_;
}
inline uint32_t Arp::protocol_size() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.protocol_size)
  return _internal_protocol_size();
}
inline void Arp::_internal_set_protocol_size(uint32_t value) {
  
  _impl_.protocol_size_ = value;
}
inline void Arp::set_protocol_size(uint32_t value) {
  _internal_set_protocol_size(value);
  // @@protoc_insertion_point(field_set:Protocol.Arp.protocol_size)
}

// uint32 op_type = 5;
inline void Arp::clear_op_type() {
  _impl_.op_type_ = 0u;
}
inline uint32_t Arp::_internal_op_type() const {
  return _impl_.op_type_;
}
inline uint32_t Arp::op_type() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.op_type)
  return _internal_op_type();
}
inline void Arp::_internal_set_op_type(uint32_t value) {
  
  _impl_.op_type_ = value;
}
inline void Arp::set_op_type(uint32_t value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Arp.op_type)
}

// string source_mac = 6;
inline void Arp::clear_source_mac() {
  _impl_.source_mac_.ClearToEmpty();
}
inline const std::string& Arp::source_mac() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.source_mac)
  return _internal_source_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arp::set_source_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Arp.source_mac)
}
inline std::string* Arp::mutable_source_mac() {
  std::string* _s = _internal_mutable_source_mac();
  // @@protoc_insertion_point(field_mutable:Protocol.Arp.source_mac)
  return _s;
}
inline const std::string& Arp::_internal_source_mac() const {
  return _impl_.source_mac_.Get();
}
inline void Arp::_internal_set_source_mac(const std::string& value) {
  
  _impl_.source_mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Arp::_internal_mutable_source_mac() {
  
  return _impl_.source_mac_.Mutable(GetArenaForAllocation());
}
inline std::string* Arp::release_source_mac() {
  // @@protoc_insertion_point(field_release:Protocol.Arp.source_mac)
  return _impl_.source_mac_.Release();
}
inline void Arp::set_allocated_source_mac(std::string* source_mac) {
  if (source_mac != nullptr) {
    
  } else {
    
  }
  _impl_.source_mac_.SetAllocated(source_mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_mac_.IsDefault()) {
    _impl_.source_mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Arp.source_mac)
}

// string source_ip = 7;
inline void Arp::clear_source_ip() {
  _impl_.source_ip_.ClearToEmpty();
}
inline const std::string& Arp::source_ip() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arp::set_source_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Arp.source_ip)
}
inline std::string* Arp::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.Arp.source_ip)
  return _s;
}
inline const std::string& Arp::_internal_source_ip() const {
  return _impl_.source_ip_.Get();
}
inline void Arp::_internal_set_source_ip(const std::string& value) {
  
  _impl_.source_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Arp::_internal_mutable_source_ip() {
  
  return _impl_.source_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Arp::release_source_ip() {
  // @@protoc_insertion_point(field_release:Protocol.Arp.source_ip)
  return _impl_.source_ip_.Release();
}
inline void Arp::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    
  } else {
    
  }
  _impl_.source_ip_.SetAllocated(source_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Arp.source_ip)
}

// string target_mac = 8;
inline void Arp::clear_target_mac() {
  _impl_.target_mac_.ClearToEmpty();
}
inline const std::string& Arp::target_mac() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.target_mac)
  return _internal_target_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arp::set_target_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Arp.target_mac)
}
inline std::string* Arp::mutable_target_mac() {
  std::string* _s = _internal_mutable_target_mac();
  // @@protoc_insertion_point(field_mutable:Protocol.Arp.target_mac)
  return _s;
}
inline const std::string& Arp::_internal_target_mac() const {
  return _impl_.target_mac_.Get();
}
inline void Arp::_internal_set_target_mac(const std::string& value) {
  
  _impl_.target_mac_.Set(value, GetArenaForAllocation());
}
inline std::string* Arp::_internal_mutable_target_mac() {
  
  return _impl_.target_mac_.Mutable(GetArenaForAllocation());
}
inline std::string* Arp::release_target_mac() {
  // @@protoc_insertion_point(field_release:Protocol.Arp.target_mac)
  return _impl_.target_mac_.Release();
}
inline void Arp::set_allocated_target_mac(std::string* target_mac) {
  if (target_mac != nullptr) {
    
  } else {
    
  }
  _impl_.target_mac_.SetAllocated(target_mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_mac_.IsDefault()) {
    _impl_.target_mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Arp.target_mac)
}

// string target_ip = 9;
inline void Arp::clear_target_ip() {
  _impl_.target_ip_.ClearToEmpty();
}
inline const std::string& Arp::target_ip() const {
  // @@protoc_insertion_point(field_get:Protocol.Arp.target_ip)
  return _internal_target_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arp::set_target_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Arp.target_ip)
}
inline std::string* Arp::mutable_target_ip() {
  std::string* _s = _internal_mutable_target_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.Arp.target_ip)
  return _s;
}
inline const std::string& Arp::_internal_target_ip() const {
  return _impl_.target_ip_.Get();
}
inline void Arp::_internal_set_target_ip(const std::string& value) {
  
  _impl_.target_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Arp::_internal_mutable_target_ip() {
  
  return _impl_.target_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Arp::release_target_ip() {
  // @@protoc_insertion_point(field_release:Protocol.Arp.target_ip)
  return _impl_.target_ip_.Release();
}
inline void Arp::set_allocated_target_ip(std::string* target_ip) {
  if (target_ip != nullptr) {
    
  } else {
    
  }
  _impl_.target_ip_.SetAllocated(target_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_ip_.IsDefault()) {
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Arp.target_ip)
}

// -------------------------------------------------------------------

// Ip

// uint32 version = 1;
inline void Ip::clear_version() {
  _impl_.version_ = 0u;
}
inline uint32_t Ip::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t Ip::version() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.version)
  return _internal_version();
}
inline void Ip::_internal_set_version(uint32_t value) {
  
  _impl_.version_ = value;
}
inline void Ip::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.version)
}

// uint32 header_len = 2;
inline void Ip::clear_header_len() {
  _impl_.header_len_ = 0u;
}
inline uint32_t Ip::_internal_header_len() const {
  return _impl_.header_len_;
}
inline uint32_t Ip::header_len() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.header_len)
  return _internal_header_len();
}
inline void Ip::_internal_set_header_len(uint32_t value) {
  
  _impl_.header_len_ = value;
}
inline void Ip::set_header_len(uint32_t value) {
  _internal_set_header_len(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.header_len)
}

// uint32 service_type = 3;
inline void Ip::clear_service_type() {
  _impl_.service_type_ = 0u;
}
inline uint32_t Ip::_internal_service_type() const {
  return _impl_.service_type_;
}
inline uint32_t Ip::service_type() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.service_type)
  return _internal_service_type();
}
inline void Ip::_internal_set_service_type(uint32_t value) {
  
  _impl_.service_type_ = value;
}
inline void Ip::set_service_type(uint32_t value) {
  _internal_set_service_type(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.service_type)
}

// uint32 total_len = 4;
inline void Ip::clear_total_len() {
  _impl_.total_len_ = 0u;
}
inline uint32_t Ip::_internal_total_len() const {
  return _impl_.total_len_;
}
inline uint32_t Ip::total_len() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.total_len)
  return _internal_total_len();
}
inline void Ip::_internal_set_total_len(uint32_t value) {
  
  _impl_.total_len_ = value;
}
inline void Ip::set_total_len(uint32_t value) {
  _internal_set_total_len(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.total_len)
}

// uint32 identification = 5;
inline void Ip::clear_identification() {
  _impl_.identification_ = 0u;
}
inline uint32_t Ip::_internal_identification() const {
  return _impl_.identification_;
}
inline uint32_t Ip::identification() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.identification)
  return _internal_identification();
}
inline void Ip::_internal_set_identification(uint32_t value) {
  
  _impl_.identification_ = value;
}
inline void Ip::set_identification(uint32_t value) {
  _internal_set_identification(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.identification)
}

// uint32 flags = 6;
inline void Ip::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t Ip::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t Ip::flags() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.flags)
  return _internal_flags();
}
inline void Ip::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void Ip::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.flags)
}

// uint32 fragment_offset = 7;
inline void Ip::clear_fragment_offset() {
  _impl_.fragment_offset_ = 0u;
}
inline uint32_t Ip::_internal_fragment_offset() const {
  return _impl_.fragment_offset_;
}
inline uint32_t Ip::fragment_offset() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.fragment_offset)
  return _internal_fragment_offset();
}
inline void Ip::_internal_set_fragment_offset(uint32_t value) {
  
  _impl_.fragment_offset_ = value;
}
inline void Ip::set_fragment_offset(uint32_t value) {
  _internal_set_fragment_offset(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.fragment_offset)
}

// uint32 ttl = 8;
inline void Ip::clear_ttl() {
  _impl_.ttl_ = 0u;
}
inline uint32_t Ip::_internal_ttl() const {
  return _impl_.ttl_;
}
inline uint32_t Ip::ttl() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.ttl)
  return _internal_ttl();
}
inline void Ip::_internal_set_ttl(uint32_t value) {
  
  _impl_.ttl_ = value;
}
inline void Ip::set_ttl(uint32_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.ttl)
}

// uint32 protocol = 9;
inline void Ip::clear_protocol() {
  _impl_.protocol_ = 0u;
}
inline uint32_t Ip::_internal_protocol() const {
  return _impl_.protocol_;
}
inline uint32_t Ip::protocol() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.protocol)
  return _internal_protocol();
}
inline void Ip::_internal_set_protocol(uint32_t value) {
  
  _impl_.protocol_ = value;
}
inline void Ip::set_protocol(uint32_t value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.protocol)
}

// uint32 checksum = 10;
inline void Ip::clear_checksum() {
  _impl_.checksum_ = 0u;
}
inline uint32_t Ip::_internal_checksum() const {
  return _impl_.checksum_;
}
inline uint32_t Ip::checksum() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.checksum)
  return _internal_checksum();
}
inline void Ip::_internal_set_checksum(uint32_t value) {
  
  _impl_.checksum_ = value;
}
inline void Ip::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:Protocol.Ip.checksum)
}

// string source_ip = 11;
inline void Ip::clear_source_ip() {
  _impl_.source_ip_.ClearToEmpty();
}
inline const std::string& Ip::source_ip() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.source_ip)
  return _internal_source_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ip::set_source_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.source_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Ip.source_ip)
}
inline std::string* Ip::mutable_source_ip() {
  std::string* _s = _internal_mutable_source_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.Ip.source_ip)
  return _s;
}
inline const std::string& Ip::_internal_source_ip() const {
  return _impl_.source_ip_.Get();
}
inline void Ip::_internal_set_source_ip(const std::string& value) {
  
  _impl_.source_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Ip::_internal_mutable_source_ip() {
  
  return _impl_.source_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Ip::release_source_ip() {
  // @@protoc_insertion_point(field_release:Protocol.Ip.source_ip)
  return _impl_.source_ip_.Release();
}
inline void Ip::set_allocated_source_ip(std::string* source_ip) {
  if (source_ip != nullptr) {
    
  } else {
    
  }
  _impl_.source_ip_.SetAllocated(source_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.source_ip_.IsDefault()) {
    _impl_.source_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Ip.source_ip)
}

// string target_ip = 12;
inline void Ip::clear_target_ip() {
  _impl_.target_ip_.ClearToEmpty();
}
inline const std::string& Ip::target_ip() const {
  // @@protoc_insertion_point(field_get:Protocol.Ip.target_ip)
  return _internal_target_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ip::set_target_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.target_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Ip.target_ip)
}
inline std::string* Ip::mutable_target_ip() {
  std::string* _s = _internal_mutable_target_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.Ip.target_ip)
  return _s;
}
inline const std::string& Ip::_internal_target_ip() const {
  return _impl_.target_ip_.Get();
}
inline void Ip::_internal_set_target_ip(const std::string& value) {
  
  _impl_.target_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Ip::_internal_mutable_target_ip() {
  
  return _impl_.target_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Ip::release_target_ip() {
  // @@protoc_insertion_point(field_release:Protocol.Ip.target_ip)
  return _impl_.target_ip_.Release();
}
inline void Ip::set_allocated_target_ip(std::string* target_ip) {
  if (target_ip != nullptr) {
    
  } else {
    
  }
  _impl_.target_ip_.SetAllocated(target_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.target_ip_.IsDefault()) {
    _impl_.target_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Ip.target_ip)
}

// -------------------------------------------------------------------

// Udp

// uint32 source_port = 1;
inline void Udp::clear_source_port() {
  _impl_.source_port_ = 0u;
}
inline uint32_t Udp::_internal_source_port() const {
  return _impl_.source_port_;
}
inline uint32_t Udp::source_port() const {
  // @@protoc_insertion_point(field_get:Protocol.Udp.source_port)
  return _internal_source_port();
}
inline void Udp::_internal_set_source_port(uint32_t value) {
  
  _impl_.source_port_ = value;
}
inline void Udp::set_source_port(uint32_t value) {
  _internal_set_source_port(value);
  // @@protoc_insertion_point(field_set:Protocol.Udp.source_port)
}

// uint32 target_port = 2;
inline void Udp::clear_target_port() {
  _impl_.target_port_ = 0u;
}
inline uint32_t Udp::_internal_target_port() const {
  return _impl_.target_port_;
}
inline uint32_t Udp::target_port() const {
  // @@protoc_insertion_point(field_get:Protocol.Udp.target_port)
  return _internal_target_port();
}
inline void Udp::_internal_set_target_port(uint32_t value) {
  
  _impl_.target_port_ = value;
}
inline void Udp::set_target_port(uint32_t value) {
  _internal_set_target_port(value);
  // @@protoc_insertion_point(field_set:Protocol.Udp.target_port)
}

// uint32 total_size = 3;
inline void Udp::clear_total_size() {
  _impl_.total_size_ = 0u;
}
inline uint32_t Udp::_internal_total_size() const {
  return _impl_.total_size_;
}
inline uint32_t Udp::total_size() const {
  // @@protoc_insertion_point(field_get:Protocol.Udp.total_size)
  return _internal_total_size();
}
inline void Udp::_internal_set_total_size(uint32_t value) {
  
  _impl_.total_size_ = value;
}
inline void Udp::set_total_size(uint32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:Protocol.Udp.total_size)
}

// uint32 check_sum = 4;
inline void Udp::clear_check_sum() {
  _impl_.check_sum_ = 0u;
}
inline uint32_t Udp::_internal_check_sum() const {
  return _impl_.check_sum_;
}
inline uint32_t Udp::check_sum() const {
  // @@protoc_insertion_point(field_get:Protocol.Udp.check_sum)
  return _internal_check_sum();
}
inline void Udp::_internal_set_check_sum(uint32_t value) {
  
  _impl_.check_sum_ = value;
}
inline void Udp::set_check_sum(uint32_t value) {
  _internal_set_check_sum(value);
  // @@protoc_insertion_point(field_set:Protocol.Udp.check_sum)
}

// -------------------------------------------------------------------

// Dns

// uint32 transaction_id = 1;
inline void Dns::clear_transaction_id() {
  _impl_.transaction_id_ = 0u;
}
inline uint32_t Dns::_internal_transaction_id() const {
  return _impl_.transaction_id_;
}
inline uint32_t Dns::transaction_id() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.transaction_id)
  return _internal_transaction_id();
}
inline void Dns::_internal_set_transaction_id(uint32_t value) {
  
  _impl_.transaction_id_ = value;
}
inline void Dns::set_transaction_id(uint32_t value) {
  _internal_set_transaction_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.transaction_id)
}

// bool is_response = 2;
inline void Dns::clear_is_response() {
  _impl_.is_response_ = false;
}
inline bool Dns::_internal_is_response() const {
  return _impl_.is_response_;
}
inline bool Dns::is_response() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.is_response)
  return _internal_is_response();
}
inline void Dns::_internal_set_is_response(bool value) {
  
  _impl_.is_response_ = value;
}
inline void Dns::set_is_response(bool value) {
  _internal_set_is_response(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.is_response)
}

// uint32 op_code = 3;
inline void Dns::clear_op_code() {
  _impl_.op_code_ = 0u;
}
inline uint32_t Dns::_internal_op_code() const {
  return _impl_.op_code_;
}
inline uint32_t Dns::op_code() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.op_code)
  return _internal_op_code();
}
inline void Dns::_internal_set_op_code(uint32_t value) {
  
  _impl_.op_code_ = value;
}
inline void Dns::set_op_code(uint32_t value) {
  _internal_set_op_code(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.op_code)
}

// bool is_authenticated_answer = 4;
inline void Dns::clear_is_authenticated_answer() {
  _impl_.is_authenticated_answer_ = false;
}
inline bool Dns::_internal_is_authenticated_answer() const {
  return _impl_.is_authenticated_answer_;
}
inline bool Dns::is_authenticated_answer() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.is_authenticated_answer)
  return _internal_is_authenticated_answer();
}
inline void Dns::_internal_set_is_authenticated_answer(bool value) {
  
  _impl_.is_authenticated_answer_ = value;
}
inline void Dns::set_is_authenticated_answer(bool value) {
  _internal_set_is_authenticated_answer(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.is_authenticated_answer)
}

// bool is_truncated = 5;
inline void Dns::clear_is_truncated() {
  _impl_.is_truncated_ = false;
}
inline bool Dns::_internal_is_truncated() const {
  return _impl_.is_truncated_;
}
inline bool Dns::is_truncated() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.is_truncated)
  return _internal_is_truncated();
}
inline void Dns::_internal_set_is_truncated(bool value) {
  
  _impl_.is_truncated_ = value;
}
inline void Dns::set_is_truncated(bool value) {
  _internal_set_is_truncated(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.is_truncated)
}

// bool is_recursion_desired = 6;
inline void Dns::clear_is_recursion_desired() {
  _impl_.is_recursion_desired_ = false;
}
inline bool Dns::_internal_is_recursion_desired() const {
  return _impl_.is_recursion_desired_;
}
inline bool Dns::is_recursion_desired() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.is_recursion_desired)
  return _internal_is_recursion_desired();
}
inline void Dns::_internal_set_is_recursion_desired(bool value) {
  
  _impl_.is_recursion_desired_ = value;
}
inline void Dns::set_is_recursion_desired(bool value) {
  _internal_set_is_recursion_desired(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.is_recursion_desired)
}

// bool is_recursion_available = 7;
inline void Dns::clear_is_recursion_available() {
  _impl_.is_recursion_available_ = false;
}
inline bool Dns::_internal_is_recursion_available() const {
  return _impl_.is_recursion_available_;
}
inline bool Dns::is_recursion_available() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.is_recursion_available)
  return _internal_is_recursion_available();
}
inline void Dns::_internal_set_is_recursion_available(bool value) {
  
  _impl_.is_recursion_available_ = value;
}
inline void Dns::set_is_recursion_available(bool value) {
  _internal_set_is_recursion_available(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.is_recursion_available)
}

// uint32 reply_code = 8;
inline void Dns::clear_reply_code() {
  _impl_.reply_code_ = 0u;
}
inline uint32_t Dns::_internal_reply_code() const {
  return _impl_.reply_code_;
}
inline uint32_t Dns::reply_code() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.reply_code)
  return _internal_reply_code();
}
inline void Dns::_internal_set_reply_code(uint32_t value) {
  
  _impl_.reply_code_ = value;
}
inline void Dns::set_reply_code(uint32_t value) {
  _internal_set_reply_code(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.reply_code)
}

// uint32 question_amount = 9;
inline void Dns::clear_question_amount() {
  _impl_.question_amount_ = 0u;
}
inline uint32_t Dns::_internal_question_amount() const {
  return _impl_.question_amount_;
}
inline uint32_t Dns::question_amount() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.question_amount)
  return _internal_question_amount();
}
inline void Dns::_internal_set_question_amount(uint32_t value) {
  
  _impl_.question_amount_ = value;
}
inline void Dns::set_question_amount(uint32_t value) {
  _internal_set_question_amount(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.question_amount)
}

// uint32 answer_amount = 10;
inline void Dns::clear_answer_amount() {
  _impl_.answer_amount_ = 0u;
}
inline uint32_t Dns::_internal_answer_amount() const {
  return _impl_.answer_amount_;
}
inline uint32_t Dns::answer_amount() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.answer_amount)
  return _internal_answer_amount();
}
inline void Dns::_internal_set_answer_amount(uint32_t value) {
  
  _impl_.answer_amount_ = value;
}
inline void Dns::set_answer_amount(uint32_t value) {
  _internal_set_answer_amount(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.answer_amount)
}

// uint32 authority_amount = 11;
inline void Dns::clear_authority_amount() {
  _impl_.authority_amount_ = 0u;
}
inline uint32_t Dns::_internal_authority_amount() const {
  return _impl_.authority_amount_;
}
inline uint32_t Dns::authority_amount() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.authority_amount)
  return _internal_authority_amount();
}
inline void Dns::_internal_set_authority_amount(uint32_t value) {
  
  _impl_.authority_amount_ = value;
}
inline void Dns::set_authority_amount(uint32_t value) {
  _internal_set_authority_amount(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.authority_amount)
}

// uint32 additional_amount = 12;
inline void Dns::clear_additional_amount() {
  _impl_.additional_amount_ = 0u;
}
inline uint32_t Dns::_internal_additional_amount() const {
  return _impl_.additional_amount_;
}
inline uint32_t Dns::additional_amount() const {
  // @@protoc_insertion_point(field_get:Protocol.Dns.additional_amount)
  return _internal_additional_amount();
}
inline void Dns::_internal_set_additional_amount(uint32_t value) {
  
  _impl_.additional_amount_ = value;
}
inline void Dns::set_additional_amount(uint32_t value) {
  _internal_set_additional_amount(value);
  // @@protoc_insertion_point(field_set:Protocol.Dns.additional_amount)
}

// -------------------------------------------------------------------

// Tcp

// uint32 source_port = 1;
inline void Tcp::clear_source_port() {
  _impl_.source_port_ = 0u;
}
inline uint32_t Tcp::_internal_source_port() const {
  return _impl_.source_port_;
}
inline uint32_t Tcp::source_port() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.source_port)
  return _internal_source_port();
}
inline void Tcp::_internal_set_source_port(uint32_t value) {
  
  _impl_.source_port_ = value;
}
inline void Tcp::set_source_port(uint32_t value) {
  _internal_set_source_port(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.source_port)
}

// uint32 target_port = 2;
inline void Tcp::clear_target_port() {
  _impl_.target_port_ = 0u;
}
inline uint32_t Tcp::_internal_target_port() const {
  return _impl_.target_port_;
}
inline uint32_t Tcp::target_port() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.target_port)
  return _internal_target_port();
}
inline void Tcp::_internal_set_target_port(uint32_t value) {
  
  _impl_.target_port_ = value;
}
inline void Tcp::set_target_port(uint32_t value) {
  _internal_set_target_port(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.target_port)
}

// uint32 seq_num = 3;
inline void Tcp::clear_seq_num() {
  _impl_.seq_num_ = 0u;
}
inline uint32_t Tcp::_internal_seq_num() const {
  return _impl_.seq_num_;
}
inline uint32_t Tcp::seq_num() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.seq_num)
  return _internal_seq_num();
}
inline void Tcp::_internal_set_seq_num(uint32_t value) {
  
  _impl_.seq_num_ = value;
}
inline void Tcp::set_seq_num(uint32_t value) {
  _internal_set_seq_num(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.seq_num)
}

// uint32 ack_num = 4;
inline void Tcp::clear_ack_num() {
  _impl_.ack_num_ = 0u;
}
inline uint32_t Tcp::_internal_ack_num() const {
  return _impl_.ack_num_;
}
inline uint32_t Tcp::ack_num() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.ack_num)
  return _internal_ack_num();
}
inline void Tcp::_internal_set_ack_num(uint32_t value) {
  
  _impl_.ack_num_ = value;
}
inline void Tcp::set_ack_num(uint32_t value) {
  _internal_set_ack_num(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.ack_num)
}

// uint32 header_len = 5;
inline void Tcp::clear_header_len() {
  _impl_.header_len_ = 0u;
}
inline uint32_t Tcp::_internal_header_len() const {
  return _impl_.header_len_;
}
inline uint32_t Tcp::header_len() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.header_len)
  return _internal_header_len();
}
inline void Tcp::_internal_set_header_len(uint32_t value) {
  
  _impl_.header_len_ = value;
}
inline void Tcp::set_header_len(uint32_t value) {
  _internal_set_header_len(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.header_len)
}

// uint32 reserve = 6;
inline void Tcp::clear_reserve() {
  _impl_.reserve_ = 0u;
}
inline uint32_t Tcp::_internal_reserve() const {
  return _impl_.reserve_;
}
inline uint32_t Tcp::reserve() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.reserve)
  return _internal_reserve();
}
inline void Tcp::_internal_set_reserve(uint32_t value) {
  
  _impl_.reserve_ = value;
}
inline void Tcp::set_reserve(uint32_t value) {
  _internal_set_reserve(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.reserve)
}

// bool urg = 7;
inline void Tcp::clear_urg() {
  _impl_.urg_ = false;
}
inline bool Tcp::_internal_urg() const {
  return _impl_.urg_;
}
inline bool Tcp::urg() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.urg)
  return _internal_urg();
}
inline void Tcp::_internal_set_urg(bool value) {
  
  _impl_.urg_ = value;
}
inline void Tcp::set_urg(bool value) {
  _internal_set_urg(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.urg)
}

// bool syn = 8;
inline void Tcp::clear_syn() {
  _impl_.syn_ = false;
}
inline bool Tcp::_internal_syn() const {
  return _impl_.syn_;
}
inline bool Tcp::syn() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.syn)
  return _internal_syn();
}
inline void Tcp::_internal_set_syn(bool value) {
  
  _impl_.syn_ = value;
}
inline void Tcp::set_syn(bool value) {
  _internal_set_syn(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.syn)
}

// bool ack = 9;
inline void Tcp::clear_ack() {
  _impl_.ack_ = false;
}
inline bool Tcp::_internal_ack() const {
  return _impl_.ack_;
}
inline bool Tcp::ack() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.ack)
  return _internal_ack();
}
inline void Tcp::_internal_set_ack(bool value) {
  
  _impl_.ack_ = value;
}
inline void Tcp::set_ack(bool value) {
  _internal_set_ack(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.ack)
}

// uint32 window = 10;
inline void Tcp::clear_window() {
  _impl_.window_ = 0u;
}
inline uint32_t Tcp::_internal_window() const {
  return _impl_.window_;
}
inline uint32_t Tcp::window() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.window)
  return _internal_window();
}
inline void Tcp::_internal_set_window(uint32_t value) {
  
  _impl_.window_ = value;
}
inline void Tcp::set_window(uint32_t value) {
  _internal_set_window(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.window)
}

// uint32 checksum = 11;
inline void Tcp::clear_checksum() {
  _impl_.checksum_ = 0u;
}
inline uint32_t Tcp::_internal_checksum() const {
  return _impl_.checksum_;
}
inline uint32_t Tcp::checksum() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.checksum)
  return _internal_checksum();
}
inline void Tcp::_internal_set_checksum(uint32_t value) {
  
  _impl_.checksum_ = value;
}
inline void Tcp::set_checksum(uint32_t value) {
  _internal_set_checksum(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.checksum)
}

// uint32 urgent_pointer = 12;
inline void Tcp::clear_urgent_pointer() {
  _impl_.urgent_pointer_ = 0u;
}
inline uint32_t Tcp::_internal_urgent_pointer() const {
  return _impl_.urgent_pointer_;
}
inline uint32_t Tcp::urgent_pointer() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.urgent_pointer)
  return _internal_urgent_pointer();
}
inline void Tcp::_internal_set_urgent_pointer(uint32_t value) {
  
  _impl_.urgent_pointer_ = value;
}
inline void Tcp::set_urgent_pointer(uint32_t value) {
  _internal_set_urgent_pointer(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.urgent_pointer)
}

// uint32 flags = 13;
inline void Tcp::clear_flags() {
  _impl_.flags_ = 0u;
}
inline uint32_t Tcp::_internal_flags() const {
  return _impl_.flags_;
}
inline uint32_t Tcp::flags() const {
  // @@protoc_insertion_point(field_get:Protocol.Tcp.flags)
  return _internal_flags();
}
inline void Tcp::_internal_set_flags(uint32_t value) {
  
  _impl_.flags_ = value;
}
inline void Tcp::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:Protocol.Tcp.flags)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HttpRet

// map<string, string> headers = 1;
inline int HttpRet::_internal_headers_size() const {
  return _impl_.headers_.size();
}
inline int HttpRet::headers_size() const {
  return _internal_headers_size();
}
inline void HttpRet::clear_headers() {
  _impl_.headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HttpRet::_internal_headers() const {
  return _impl_.headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HttpRet::headers() const {
  // @@protoc_insertion_point(field_map:Protocol.HttpRet.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HttpRet::_internal_mutable_headers() {
  return _impl_.headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HttpRet::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:Protocol.HttpRet.headers)
  return _internal_mutable_headers();
}

// string method = 2;
inline void HttpRet::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& HttpRet::method() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRet.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRet::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRet.method)
}
inline std::string* HttpRet::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRet.method)
  return _s;
}
inline const std::string& HttpRet::_internal_method() const {
  return _impl_.method_.Get();
}
inline void HttpRet::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRet::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRet::release_method() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRet.method)
  return _impl_.method_.Release();
}
inline void HttpRet::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRet.method)
}

// string path = 3;
inline void HttpRet::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& HttpRet::path() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRet.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRet::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRet.path)
}
inline std::string* HttpRet::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRet.path)
  return _s;
}
inline const std::string& HttpRet::_internal_path() const {
  return _impl_.path_.Get();
}
inline void HttpRet::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRet::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRet::release_path() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRet.path)
  return _impl_.path_.Release();
}
inline void HttpRet::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRet.path)
}

// string http_version = 4;
inline void HttpRet::clear_http_version() {
  _impl_.http_version_.ClearToEmpty();
}
inline const std::string& HttpRet::http_version() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRet.http_version)
  return _internal_http_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRet::set_http_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.http_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRet.http_version)
}
inline std::string* HttpRet::mutable_http_version() {
  std::string* _s = _internal_mutable_http_version();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRet.http_version)
  return _s;
}
inline const std::string& HttpRet::_internal_http_version() const {
  return _impl_.http_version_.Get();
}
inline void HttpRet::_internal_set_http_version(const std::string& value) {
  
  _impl_.http_version_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRet::_internal_mutable_http_version() {
  
  return _impl_.http_version_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRet::release_http_version() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRet.http_version)
  return _impl_.http_version_.Release();
}
inline void HttpRet::set_allocated_http_version(std::string* http_version) {
  if (http_version != nullptr) {
    
  } else {
    
  }
  _impl_.http_version_.SetAllocated(http_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.http_version_.IsDefault()) {
    _impl_.http_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRet.http_version)
}

// string body = 5;
inline void HttpRet::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& HttpRet::body() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRet.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRet::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRet.body)
}
inline std::string* HttpRet::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRet.body)
  return _s;
}
inline const std::string& HttpRet::_internal_body() const {
  return _impl_.body_.Get();
}
inline void HttpRet::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRet::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRet::release_body() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRet.body)
  return _impl_.body_.Release();
}
inline void HttpRet::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRet.body)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HttpRes

// map<string, string> headers = 1;
inline int HttpRes::_internal_headers_size() const {
  return _impl_.headers_.size();
}
inline int HttpRes::headers_size() const {
  return _internal_headers_size();
}
inline void HttpRes::clear_headers() {
  _impl_.headers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HttpRes::_internal_headers() const {
  return _impl_.headers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HttpRes::headers() const {
  // @@protoc_insertion_point(field_map:Protocol.HttpRes.headers)
  return _internal_headers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HttpRes::_internal_mutable_headers() {
  return _impl_.headers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HttpRes::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_map:Protocol.HttpRes.headers)
  return _internal_mutable_headers();
}

// string http_version = 2;
inline void HttpRes::clear_http_version() {
  _impl_.http_version_.ClearToEmpty();
}
inline const std::string& HttpRes::http_version() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRes.http_version)
  return _internal_http_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRes::set_http_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.http_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRes.http_version)
}
inline std::string* HttpRes::mutable_http_version() {
  std::string* _s = _internal_mutable_http_version();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRes.http_version)
  return _s;
}
inline const std::string& HttpRes::_internal_http_version() const {
  return _impl_.http_version_.Get();
}
inline void HttpRes::_internal_set_http_version(const std::string& value) {
  
  _impl_.http_version_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRes::_internal_mutable_http_version() {
  
  return _impl_.http_version_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRes::release_http_version() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRes.http_version)
  return _impl_.http_version_.Release();
}
inline void HttpRes::set_allocated_http_version(std::string* http_version) {
  if (http_version != nullptr) {
    
  } else {
    
  }
  _impl_.http_version_.SetAllocated(http_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.http_version_.IsDefault()) {
    _impl_.http_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRes.http_version)
}

// string status_code = 3;
inline void HttpRes::clear_status_code() {
  _impl_.status_code_.ClearToEmpty();
}
inline const std::string& HttpRes::status_code() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRes.status_code)
  return _internal_status_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRes::set_status_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRes.status_code)
}
inline std::string* HttpRes::mutable_status_code() {
  std::string* _s = _internal_mutable_status_code();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRes.status_code)
  return _s;
}
inline const std::string& HttpRes::_internal_status_code() const {
  return _impl_.status_code_.Get();
}
inline void HttpRes::_internal_set_status_code(const std::string& value) {
  
  _impl_.status_code_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRes::_internal_mutable_status_code() {
  
  return _impl_.status_code_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRes::release_status_code() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRes.status_code)
  return _impl_.status_code_.Release();
}
inline void HttpRes::set_allocated_status_code(std::string* status_code) {
  if (status_code != nullptr) {
    
  } else {
    
  }
  _impl_.status_code_.SetAllocated(status_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_code_.IsDefault()) {
    _impl_.status_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRes.status_code)
}

// string phrase = 4;
inline void HttpRes::clear_phrase() {
  _impl_.phrase_.ClearToEmpty();
}
inline const std::string& HttpRes::phrase() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRes.phrase)
  return _internal_phrase();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRes::set_phrase(ArgT0&& arg0, ArgT... args) {
 
 _impl_.phrase_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRes.phrase)
}
inline std::string* HttpRes::mutable_phrase() {
  std::string* _s = _internal_mutable_phrase();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRes.phrase)
  return _s;
}
inline const std::string& HttpRes::_internal_phrase() const {
  return _impl_.phrase_.Get();
}
inline void HttpRes::_internal_set_phrase(const std::string& value) {
  
  _impl_.phrase_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRes::_internal_mutable_phrase() {
  
  return _impl_.phrase_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRes::release_phrase() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRes.phrase)
  return _impl_.phrase_.Release();
}
inline void HttpRes::set_allocated_phrase(std::string* phrase) {
  if (phrase != nullptr) {
    
  } else {
    
  }
  _impl_.phrase_.SetAllocated(phrase, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.phrase_.IsDefault()) {
    _impl_.phrase_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRes.phrase)
}

// string body = 5;
inline void HttpRes::clear_body() {
  _impl_.body_.ClearToEmpty();
}
inline const std::string& HttpRes::body() const {
  // @@protoc_insertion_point(field_get:Protocol.HttpRes.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRes::set_body(ArgT0&& arg0, ArgT... args) {
 
 _impl_.body_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.HttpRes.body)
}
inline std::string* HttpRes::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:Protocol.HttpRes.body)
  return _s;
}
inline const std::string& HttpRes::_internal_body() const {
  return _impl_.body_.Get();
}
inline void HttpRes::_internal_set_body(const std::string& value) {
  
  _impl_.body_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRes::_internal_mutable_body() {
  
  return _impl_.body_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRes::release_body() {
  // @@protoc_insertion_point(field_release:Protocol.HttpRes.body)
  return _impl_.body_.Release();
}
inline void HttpRes::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    
  } else {
    
  }
  _impl_.body_.SetAllocated(body, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.body_.IsDefault()) {
    _impl_.body_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.HttpRes.body)
}

// -------------------------------------------------------------------

// ProtocolData

// .Protocol.Ethernet eth = 1;
inline bool ProtocolData::_internal_has_eth() const {
  return this != internal_default_instance() && _impl_.eth_ != nullptr;
}
inline bool ProtocolData::has_eth() const {
  return _internal_has_eth();
}
inline void ProtocolData::clear_eth() {
  if (GetArenaForAllocation() == nullptr && _impl_.eth_ != nullptr) {
    delete _impl_.eth_;
  }
  _impl_.eth_ = nullptr;
}
inline const ::Protocol::Ethernet& ProtocolData::_internal_eth() const {
  const ::Protocol::Ethernet* p = _impl_.eth_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Ethernet&>(
      ::Protocol::_Ethernet_default_instance_);
}
inline const ::Protocol::Ethernet& ProtocolData::eth() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.eth)
  return _internal_eth();
}
inline void ProtocolData::unsafe_arena_set_allocated_eth(
    ::Protocol::Ethernet* eth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.eth_);
  }
  _impl_.eth_ = eth;
  if (eth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.eth)
}
inline ::Protocol::Ethernet* ProtocolData::release_eth() {
  
  ::Protocol::Ethernet* temp = _impl_.eth_;
  _impl_.eth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Ethernet* ProtocolData::unsafe_arena_release_eth() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.eth)
  
  ::Protocol::Ethernet* temp = _impl_.eth_;
  _impl_.eth_ = nullptr;
  return temp;
}
inline ::Protocol::Ethernet* ProtocolData::_internal_mutable_eth() {
  
  if (_impl_.eth_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Ethernet>(GetArenaForAllocation());
    _impl_.eth_ = p;
  }
  return _impl_.eth_;
}
inline ::Protocol::Ethernet* ProtocolData::mutable_eth() {
  ::Protocol::Ethernet* _msg = _internal_mutable_eth();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.eth)
  return _msg;
}
inline void ProtocolData::set_allocated_eth(::Protocol::Ethernet* eth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.eth_;
  }
  if (eth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(eth);
    if (message_arena != submessage_arena) {
      eth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eth, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.eth_ = eth;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.eth)
}

// .Protocol.Arp arp = 2;
inline bool ProtocolData::_internal_has_arp() const {
  return this != internal_default_instance() && _impl_.arp_ != nullptr;
}
inline bool ProtocolData::has_arp() const {
  return _internal_has_arp();
}
inline void ProtocolData::clear_arp() {
  if (GetArenaForAllocation() == nullptr && _impl_.arp_ != nullptr) {
    delete _impl_.arp_;
  }
  _impl_.arp_ = nullptr;
}
inline const ::Protocol::Arp& ProtocolData::_internal_arp() const {
  const ::Protocol::Arp* p = _impl_.arp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Arp&>(
      ::Protocol::_Arp_default_instance_);
}
inline const ::Protocol::Arp& ProtocolData::arp() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.arp)
  return _internal_arp();
}
inline void ProtocolData::unsafe_arena_set_allocated_arp(
    ::Protocol::Arp* arp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.arp_);
  }
  _impl_.arp_ = arp;
  if (arp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.arp)
}
inline ::Protocol::Arp* ProtocolData::release_arp() {
  
  ::Protocol::Arp* temp = _impl_.arp_;
  _impl_.arp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Arp* ProtocolData::unsafe_arena_release_arp() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.arp)
  
  ::Protocol::Arp* temp = _impl_.arp_;
  _impl_.arp_ = nullptr;
  return temp;
}
inline ::Protocol::Arp* ProtocolData::_internal_mutable_arp() {
  
  if (_impl_.arp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Arp>(GetArenaForAllocation());
    _impl_.arp_ = p;
  }
  return _impl_.arp_;
}
inline ::Protocol::Arp* ProtocolData::mutable_arp() {
  ::Protocol::Arp* _msg = _internal_mutable_arp();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.arp)
  return _msg;
}
inline void ProtocolData::set_allocated_arp(::Protocol::Arp* arp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.arp_;
  }
  if (arp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arp);
    if (message_arena != submessage_arena) {
      arp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.arp_ = arp;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.arp)
}

// .Protocol.Ip ip = 3;
inline bool ProtocolData::_internal_has_ip() const {
  return this != internal_default_instance() && _impl_.ip_ != nullptr;
}
inline bool ProtocolData::has_ip() const {
  return _internal_has_ip();
}
inline void ProtocolData::clear_ip() {
  if (GetArenaForAllocation() == nullptr && _impl_.ip_ != nullptr) {
    delete _impl_.ip_;
  }
  _impl_.ip_ = nullptr;
}
inline const ::Protocol::Ip& ProtocolData::_internal_ip() const {
  const ::Protocol::Ip* p = _impl_.ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Ip&>(
      ::Protocol::_Ip_default_instance_);
}
inline const ::Protocol::Ip& ProtocolData::ip() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.ip)
  return _internal_ip();
}
inline void ProtocolData::unsafe_arena_set_allocated_ip(
    ::Protocol::Ip* ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ip_);
  }
  _impl_.ip_ = ip;
  if (ip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.ip)
}
inline ::Protocol::Ip* ProtocolData::release_ip() {
  
  ::Protocol::Ip* temp = _impl_.ip_;
  _impl_.ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Ip* ProtocolData::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.ip)
  
  ::Protocol::Ip* temp = _impl_.ip_;
  _impl_.ip_ = nullptr;
  return temp;
}
inline ::Protocol::Ip* ProtocolData::_internal_mutable_ip() {
  
  if (_impl_.ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Ip>(GetArenaForAllocation());
    _impl_.ip_ = p;
  }
  return _impl_.ip_;
}
inline ::Protocol::Ip* ProtocolData::mutable_ip() {
  ::Protocol::Ip* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.ip)
  return _msg;
}
inline void ProtocolData::set_allocated_ip(::Protocol::Ip* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ip_;
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ip);
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.ip)
}

// .Protocol.Udp udp = 4;
inline bool ProtocolData::_internal_has_udp() const {
  return this != internal_default_instance() && _impl_.udp_ != nullptr;
}
inline bool ProtocolData::has_udp() const {
  return _internal_has_udp();
}
inline void ProtocolData::clear_udp() {
  if (GetArenaForAllocation() == nullptr && _impl_.udp_ != nullptr) {
    delete _impl_.udp_;
  }
  _impl_.udp_ = nullptr;
}
inline const ::Protocol::Udp& ProtocolData::_internal_udp() const {
  const ::Protocol::Udp* p = _impl_.udp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Udp&>(
      ::Protocol::_Udp_default_instance_);
}
inline const ::Protocol::Udp& ProtocolData::udp() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.udp)
  return _internal_udp();
}
inline void ProtocolData::unsafe_arena_set_allocated_udp(
    ::Protocol::Udp* udp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.udp_);
  }
  _impl_.udp_ = udp;
  if (udp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.udp)
}
inline ::Protocol::Udp* ProtocolData::release_udp() {
  
  ::Protocol::Udp* temp = _impl_.udp_;
  _impl_.udp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Udp* ProtocolData::unsafe_arena_release_udp() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.udp)
  
  ::Protocol::Udp* temp = _impl_.udp_;
  _impl_.udp_ = nullptr;
  return temp;
}
inline ::Protocol::Udp* ProtocolData::_internal_mutable_udp() {
  
  if (_impl_.udp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Udp>(GetArenaForAllocation());
    _impl_.udp_ = p;
  }
  return _impl_.udp_;
}
inline ::Protocol::Udp* ProtocolData::mutable_udp() {
  ::Protocol::Udp* _msg = _internal_mutable_udp();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.udp)
  return _msg;
}
inline void ProtocolData::set_allocated_udp(::Protocol::Udp* udp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.udp_;
  }
  if (udp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(udp);
    if (message_arena != submessage_arena) {
      udp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, udp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.udp_ = udp;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.udp)
}

// .Protocol.Dns dns = 5;
inline bool ProtocolData::_internal_has_dns() const {
  return this != internal_default_instance() && _impl_.dns_ != nullptr;
}
inline bool ProtocolData::has_dns() const {
  return _internal_has_dns();
}
inline void ProtocolData::clear_dns() {
  if (GetArenaForAllocation() == nullptr && _impl_.dns_ != nullptr) {
    delete _impl_.dns_;
  }
  _impl_.dns_ = nullptr;
}
inline const ::Protocol::Dns& ProtocolData::_internal_dns() const {
  const ::Protocol::Dns* p = _impl_.dns_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Dns&>(
      ::Protocol::_Dns_default_instance_);
}
inline const ::Protocol::Dns& ProtocolData::dns() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.dns)
  return _internal_dns();
}
inline void ProtocolData::unsafe_arena_set_allocated_dns(
    ::Protocol::Dns* dns) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dns_);
  }
  _impl_.dns_ = dns;
  if (dns) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.dns)
}
inline ::Protocol::Dns* ProtocolData::release_dns() {
  
  ::Protocol::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Dns* ProtocolData::unsafe_arena_release_dns() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.dns)
  
  ::Protocol::Dns* temp = _impl_.dns_;
  _impl_.dns_ = nullptr;
  return temp;
}
inline ::Protocol::Dns* ProtocolData::_internal_mutable_dns() {
  
  if (_impl_.dns_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Dns>(GetArenaForAllocation());
    _impl_.dns_ = p;
  }
  return _impl_.dns_;
}
inline ::Protocol::Dns* ProtocolData::mutable_dns() {
  ::Protocol::Dns* _msg = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.dns)
  return _msg;
}
inline void ProtocolData::set_allocated_dns(::Protocol::Dns* dns) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dns_;
  }
  if (dns) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dns);
    if (message_arena != submessage_arena) {
      dns = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dns, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dns_ = dns;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.dns)
}

// .Protocol.Tcp tcp = 6;
inline bool ProtocolData::_internal_has_tcp() const {
  return this != internal_default_instance() && _impl_.tcp_ != nullptr;
}
inline bool ProtocolData::has_tcp() const {
  return _internal_has_tcp();
}
inline void ProtocolData::clear_tcp() {
  if (GetArenaForAllocation() == nullptr && _impl_.tcp_ != nullptr) {
    delete _impl_.tcp_;
  }
  _impl_.tcp_ = nullptr;
}
inline const ::Protocol::Tcp& ProtocolData::_internal_tcp() const {
  const ::Protocol::Tcp* p = _impl_.tcp_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Tcp&>(
      ::Protocol::_Tcp_default_instance_);
}
inline const ::Protocol::Tcp& ProtocolData::tcp() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.tcp)
  return _internal_tcp();
}
inline void ProtocolData::unsafe_arena_set_allocated_tcp(
    ::Protocol::Tcp* tcp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tcp_);
  }
  _impl_.tcp_ = tcp;
  if (tcp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.tcp)
}
inline ::Protocol::Tcp* ProtocolData::release_tcp() {
  
  ::Protocol::Tcp* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Tcp* ProtocolData::unsafe_arena_release_tcp() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.tcp)
  
  ::Protocol::Tcp* temp = _impl_.tcp_;
  _impl_.tcp_ = nullptr;
  return temp;
}
inline ::Protocol::Tcp* ProtocolData::_internal_mutable_tcp() {
  
  if (_impl_.tcp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Tcp>(GetArenaForAllocation());
    _impl_.tcp_ = p;
  }
  return _impl_.tcp_;
}
inline ::Protocol::Tcp* ProtocolData::mutable_tcp() {
  ::Protocol::Tcp* _msg = _internal_mutable_tcp();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.tcp)
  return _msg;
}
inline void ProtocolData::set_allocated_tcp(::Protocol::Tcp* tcp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tcp_;
  }
  if (tcp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tcp);
    if (message_arena != submessage_arena) {
      tcp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tcp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tcp_ = tcp;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.tcp)
}

// .Protocol.HttpRet http_request = 7;
inline bool ProtocolData::_internal_has_http_request() const {
  return this != internal_default_instance() && _impl_.http_request_ != nullptr;
}
inline bool ProtocolData::has_http_request() const {
  return _internal_has_http_request();
}
inline void ProtocolData::clear_http_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.http_request_ != nullptr) {
    delete _impl_.http_request_;
  }
  _impl_.http_request_ = nullptr;
}
inline const ::Protocol::HttpRet& ProtocolData::_internal_http_request() const {
  const ::Protocol::HttpRet* p = _impl_.http_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::HttpRet&>(
      ::Protocol::_HttpRet_default_instance_);
}
inline const ::Protocol::HttpRet& ProtocolData::http_request() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.http_request)
  return _internal_http_request();
}
inline void ProtocolData::unsafe_arena_set_allocated_http_request(
    ::Protocol::HttpRet* http_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.http_request_);
  }
  _impl_.http_request_ = http_request;
  if (http_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.http_request)
}
inline ::Protocol::HttpRet* ProtocolData::release_http_request() {
  
  ::Protocol::HttpRet* temp = _impl_.http_request_;
  _impl_.http_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::HttpRet* ProtocolData::unsafe_arena_release_http_request() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.http_request)
  
  ::Protocol::HttpRet* temp = _impl_.http_request_;
  _impl_.http_request_ = nullptr;
  return temp;
}
inline ::Protocol::HttpRet* ProtocolData::_internal_mutable_http_request() {
  
  if (_impl_.http_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::HttpRet>(GetArenaForAllocation());
    _impl_.http_request_ = p;
  }
  return _impl_.http_request_;
}
inline ::Protocol::HttpRet* ProtocolData::mutable_http_request() {
  ::Protocol::HttpRet* _msg = _internal_mutable_http_request();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.http_request)
  return _msg;
}
inline void ProtocolData::set_allocated_http_request(::Protocol::HttpRet* http_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.http_request_;
  }
  if (http_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(http_request);
    if (message_arena != submessage_arena) {
      http_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, http_request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.http_request_ = http_request;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.http_request)
}

// .Protocol.HttpRes http_response = 8;
inline bool ProtocolData::_internal_has_http_response() const {
  return this != internal_default_instance() && _impl_.http_response_ != nullptr;
}
inline bool ProtocolData::has_http_response() const {
  return _internal_has_http_response();
}
inline void ProtocolData::clear_http_response() {
  if (GetArenaForAllocation() == nullptr && _impl_.http_response_ != nullptr) {
    delete _impl_.http_response_;
  }
  _impl_.http_response_ = nullptr;
}
inline const ::Protocol::HttpRes& ProtocolData::_internal_http_response() const {
  const ::Protocol::HttpRes* p = _impl_.http_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::HttpRes&>(
      ::Protocol::_HttpRes_default_instance_);
}
inline const ::Protocol::HttpRes& ProtocolData::http_response() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.http_response)
  return _internal_http_response();
}
inline void ProtocolData::unsafe_arena_set_allocated_http_response(
    ::Protocol::HttpRes* http_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.http_response_);
  }
  _impl_.http_response_ = http_response;
  if (http_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.ProtocolData.http_response)
}
inline ::Protocol::HttpRes* ProtocolData::release_http_response() {
  
  ::Protocol::HttpRes* temp = _impl_.http_response_;
  _impl_.http_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::HttpRes* ProtocolData::unsafe_arena_release_http_response() {
  // @@protoc_insertion_point(field_release:Protocol.ProtocolData.http_response)
  
  ::Protocol::HttpRes* temp = _impl_.http_response_;
  _impl_.http_response_ = nullptr;
  return temp;
}
inline ::Protocol::HttpRes* ProtocolData::_internal_mutable_http_response() {
  
  if (_impl_.http_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::HttpRes>(GetArenaForAllocation());
    _impl_.http_response_ = p;
  }
  return _impl_.http_response_;
}
inline ::Protocol::HttpRes* ProtocolData::mutable_http_response() {
  ::Protocol::HttpRes* _msg = _internal_mutable_http_response();
  // @@protoc_insertion_point(field_mutable:Protocol.ProtocolData.http_response)
  return _msg;
}
inline void ProtocolData::set_allocated_http_response(::Protocol::HttpRes* http_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.http_response_;
  }
  if (http_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(http_response);
    if (message_arena != submessage_arena) {
      http_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, http_response, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.http_response_ = http_response;
  // @@protoc_insertion_point(field_set_allocated:Protocol.ProtocolData.http_response)
}

// uint32 type = 9;
inline void ProtocolData::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t ProtocolData::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t ProtocolData::type() const {
  // @@protoc_insertion_point(field_get:Protocol.ProtocolData.type)
  return _internal_type();
}
inline void ProtocolData::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void ProtocolData::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Protocol.ProtocolData.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_data_2eproto
